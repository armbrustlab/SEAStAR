// Generated by CoffeeScript 1.12.7

/*
 * -------------------------------------------------------------------------- #
 * Center for Environmental Genomics
 * Copyright (C) 2009-2013 University of Washington.
 *
 * Authors:
 * Vaughn Iverson
 * vsi@uw.edu
 * -------------------------------------------------------------------------- #
 * This file is part of SEAStAR.
 *
 * SEAStAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SEAStAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
 * -------------------------------------------------------------------------- #
 *
 * This script reads in one or more JSON formatted heirarchy files and merges
 * them into to a new unified JSON tree formatted output file.
 *
 * Inputs: JSON formatted heirarchy files in the global variable input_files.
 *
 * Output: output JSON formatted heirarchy to stdout
 *
 * Output file format:
 * Each taxonomic unit in the RDP input file becomes a branch in the output JSON tree.
 * Each branch has the following JSON structure:
 *
 * name : {
 *      "pop" : <fraction of the sample>,
 *      "cum" : <cumulative fraction of the sample>,
 *      "num" : <number of sequences>,
 *      "cnt" : <cumulative number of seqeunces>,
 *      "conf" : <mean classifier p-value for sequences in this taxon>,
 *      "w_conf" : <population weighted mean classifier p-value for sequences in this taxon>,
 *      "level" : <numeric level in heirarchy>,
 *      "length" : <branch length of this taxonomic level from parent>
 *      "samples" : <sample child nodes containing pop, cum, num, cnt and conf>
 *      "sub" : {<child nodes by name, or empty if a leaf>}
 * }
 *
 */

(function() {
  var fs, i, input_files, j, len, merge, output_tree, path, ref, sample_file, sample_name, ver, walk;

  ver = process.version.slice(1).split('.');

  if (!(ver[1] >= 10 || ver[0] > 0)) {
    console.error("ERROR: nodejs version v0.10.0 or greater required.");
    process.exit(1);
  }

  fs = require('fs');

  path = require('path');

  input_files = {};

  ref = process.argv.slice(2);
  for (j = 0, len = ref.length; j < len; j++) {
    i = ref[j];
    input_files[path.basename(i).split("_")[0]] = i;
  }

  if (Object.keys(input_files).length === 0) {
    process.stderr.write("No input files found!\n");
    process.exit(1);
  }

  output_tree = {
    sample_names: [],
    sub: {}
  };

  walk = function(tree, prev_cnt, prev_cum) {
    var c, results, sub_tree;
    results = [];
    for (c in tree.sub) {
      sub_tree = tree.sub[c];
      sub_tree.cnt = prev_cnt;
      sub_tree.cum = prev_cum;
      walk(sub_tree, prev_cnt, prev_cum);
      prev_cnt += sub_tree.num;
      results.push(prev_cum += sub_tree.pop);
    }
    return results;
  };

  merge = function(out_tree, in_tree, sample, prev_cnt, prev_cum) {
    var base, c, k, ref1, results, s;
    results = [];
    for (c in in_tree.sub) {
      if (out_tree.sub[c] == null) {
        out_tree.sub[c] = in_tree.sub[c];
      }
      if ((base = out_tree.sub[c]).samples == null) {
        base.samples = [];
      }
      out_tree.sub[c].samples[sample] = {
        num: in_tree.sub[c].num,
        cnt: in_tree.sub[c].cnt,
        pop: in_tree.sub[c].pop,
        cum: in_tree.sub[c].cum,
        conf: in_tree.sub[c].conf,
        w_conf: in_tree.sub[c].w_conf
      };
      merge(out_tree.sub[c], in_tree.sub[c], sample, prev_cnt, prev_cum);
      out_tree.sub[c].num = 0;
      out_tree.sub[c].cnt = 0;
      out_tree.sub[c].pop = 0.0;
      out_tree.sub[c].cum = 0.0;
      out_tree.sub[c].conf = 0.0;
      out_tree.sub[c].w_conf = 0.0;
      ref1 = out_tree.sub[c].samples;
      for (k in ref1) {
        s = ref1[k];
        out_tree.sub[c].num += s.num;
        out_tree.sub[c].pop += s.pop;
        out_tree.sub[c].conf += s.num * s.conf;
        out_tree.sub[c].w_conf += s.pop * s.w_conf;
      }
      out_tree.sub[c].conf = Math.round(100.0 * out_tree.sub[c].conf / out_tree.sub[c].num) / 100.0;
      results.push(out_tree.sub[c].w_conf = Math.round(100.0 * out_tree.sub[c].w_conf / out_tree.sub[c].pop) / 100.0);
    }
    return results;
  };

  for (sample_name in input_files) {
    sample_file = input_files[sample_name];
    merge(output_tree, JSON.parse(fs.readFileSync(sample_file, 'utf8')), output_tree.sample_names.length, 0, 0.0);
    output_tree.sample_names.push(sample_name);
  }

  walk(output_tree, 0, 0.0);

  process.stdout.write(JSON.stringify(output_tree, null, 1));

  process.exit(0);

}).call(this);
