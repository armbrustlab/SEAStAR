// Generated by CoffeeScript 1.6.1

/*
# -------------------------------------------------------------------------- #
# Center for Environmental Genomics
# Copyright (C) 2009-2012 University of Washington.
#
# Authors:
# Vaughn Iverson
# vsi@uw.edu
# -------------------------------------------------------------------------- #
# This file is part of SEAStAR.
#
# SEAStAR is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SEAStAR is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
# -------------------------------------------------------------------------- #
#
# This script reads in one or more JSON formatted heirarchy files and merges
# them into to a new unified JSON tree formatted output file.
#
# Inputs: JSON formatted heirarchy files in the global variable input_files.
#
# Output: output JSON formatted heirarchy to stdout
#
# Output file format:
# Each taxonomic unit in the RDP input file becomes a branch in the output JSON tree.
# Each branch has the following JSON structure:
#
# name : {
#      "pop" : <fraction of the sample>,
#      "cum" : <cumulative fraction of the sample>,
#      "num" : <number of sequences>,
#      "cnt" : <cumulative number of seqeunces>,
#      "conf" : <mean classifier p-value for sequences in this taxon>,
#      "w_conf" : <population weighted mean classifier p-value for sequences in this taxon>,
#      "level" : <numeric level in heirarchy>,
#      "length" : <branch length of this taxonomic level from parent>
#      "samples" : <sample child nodes containing pop, cum, num, cnt and conf> 
#      "sub" : {<child nodes by name, or empty if a leaf>}
# }
#
*/


(function() {
  var fs, i, input_files, merge, output_tree, path, sample_file, sample_name, walk, _i, _len, _ref;

  fs = require('fs');

  path = require('path');

  input_files = {};

  _ref = process.argv.slice(2);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    i = _ref[_i];
    input_files[path.basename(i).split("_")[0]] = i;
  }

  if (Object.keys(input_files).length === 0) {
    process.stderr.write("No input files found!\n");
    process.exit(1);
  }

  output_tree = {
    sample_names: [],
    sub: {}
  };

  walk = function(tree, prev_cnt, prev_cum) {
    var c, sub_tree, _results;
    _results = [];
    for (c in tree.sub) {
      sub_tree = tree.sub[c];
      sub_tree.cnt = prev_cnt;
      sub_tree.cum = prev_cum;
      walk(sub_tree, prev_cnt, prev_cum);
      prev_cnt += sub_tree.num;
      _results.push(prev_cum += sub_tree.pop);
    }
    return _results;
  };

  merge = function(out_tree, in_tree, sample, prev_cnt, prev_cum) {
    var c, k, s, _base, _ref1, _ref2, _results;
    _results = [];
    for (c in in_tree.sub) {
      if (out_tree.sub[c] == null) {
        out_tree.sub[c] = in_tree.sub[c];
      }
      if ((_ref1 = (_base = out_tree.sub[c]).samples) == null) {
        _base.samples = [];
      }
      out_tree.sub[c].samples[sample] = {
        num: in_tree.sub[c].num,
        cnt: in_tree.sub[c].cnt,
        pop: in_tree.sub[c].pop,
        cum: in_tree.sub[c].cum,
        conf: in_tree.sub[c].conf,
        w_conf: in_tree.sub[c].w_conf
      };
      merge(out_tree.sub[c], in_tree.sub[c], sample, prev_cnt, prev_cum);
      out_tree.sub[c].num = 0;
      out_tree.sub[c].cnt = 0;
      out_tree.sub[c].pop = 0.0;
      out_tree.sub[c].cum = 0.0;
      out_tree.sub[c].conf = 0.0;
      out_tree.sub[c].w_conf = 0.0;
      _ref2 = out_tree.sub[c].samples;
      for (k in _ref2) {
        s = _ref2[k];
        out_tree.sub[c].num += s.num;
        out_tree.sub[c].pop += s.pop;
        out_tree.sub[c].conf += s.num * s.conf;
        out_tree.sub[c].w_conf += s.pop * s.w_conf;
      }
      out_tree.sub[c].conf = Math.round(100.0 * out_tree.sub[c].conf / out_tree.sub[c].num) / 100.0;
      _results.push(out_tree.sub[c].w_conf = Math.round(100.0 * out_tree.sub[c].w_conf / out_tree.sub[c].pop) / 100.0);
    }
    return _results;
  };

  for (sample_name in input_files) {
    sample_file = input_files[sample_name];
    merge(output_tree, JSON.parse(fs.readFileSync(sample_file, 'utf8')), output_tree.sample_names.length, 0, 0.0);
    output_tree.sample_names.push(sample_name);
  }

  walk(output_tree, 0, 0.0);

  process.stdout.write(JSON.stringify(output_tree, null, 1));

  process.exit(0);

}).call(this);
