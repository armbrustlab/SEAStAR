// Generated by CoffeeScript 1.12.7

/*
 * -------------------------------------------------------------------------- #
 * Center for Environmental Genomics
 * Copyright (C) 2009-2013 University of Washington.
 *
 * Authors:
 * Vaughn Iverson
 * vsi@uw.edu
 * -------------------------------------------------------------------------- #
 * This file is part of SEAStAR.
 *
 * SEAStAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SEAStAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
 * -------------------------------------------------------------------------- #
 *
 * This script reads in an RDP classifier taxonomic heirarchy file and converts
 * it to a JSON tree formatted output file.
 *
 * Inputs: input modified RDP classifier output on stdin
 *         JSON formatted RDP heirarchy in the file named in RDP_heir_fn (or RDP_expand.json by default)
 *         percent abundance below which a genus will be filtered out [0.10]
 *
 * Output:  output JSON formatted heirarchy to stdout

 * Output file format:
 * Each taxonomic unit in the RDP input file becomes a branch in the output JSON tree.
 * Each branch has the following JSON structure:
 *
 * name : {
 *      "name" : <name of this taxon>,
 *      "pop" : <fraction of the sample>,
 *      "cum" : <cumulative fraction of the sample>,
 *      "num" : <number of sequences>,
 *      "cnt" : <cumulative number of seqeunces>,
 *      "conf" : <mean classifier p-value for sequences in this taxon>,
 *      "level" : <numeric level in heirarchy>,
 *      "length" : <branch length of this taxonomic level from parent>
 *      "sub" : {<child nodes by name, or empty if a leaf>}
 * }
 */

(function() {
  var RDP_heir_fn, build, fill_lineage_gap, filter, fs, i, level_after, levels, minperc, next_incertae_sedis_name, orig_lines, out_tree, parse_line, pp, ref, ref1, ver;

  ver = process.version.slice(1).split('.');

  if (!(ver[1] >= 10 || ver[0] > 0)) {
    console.error("ERROR: nodejs version v0.10.0 or greater required.");
    process.exit(1);
  }

  fs = require('fs');

  RDP_heir_fn = (ref = process.argv[2]) != null ? ref : 'RDP_expand.json';

  minperc = parseFloat((ref1 = process.argv[3]) != null ? ref1 : 0.10);

  out_tree = JSON.parse(fs.readFileSync(RDP_heir_fn, 'utf8'));

  process.on('uncaughtException', function(err) {
    return console.log('Caught exception: ' + err);
  });

  process.stdin.setEncoding('utf8');

  process.stdin.resume();

  levels = [0, 1, 2, 3, 3.5, 4, 4.5, 5, 5.5, 5.75, 6];

  level_after = {};

  i = 0;

  while (i < levels.length - 1) {
    level_after[levels[i]] = levels[i + 1];
    i++;
  }

  out_tree.walk = function(tree, prev_cnt, prev_cum) {
    var c, results, sub_tree, tmp, y, z;
    if ((tree.sub != null) && Object.keys(tree.sub).length > 0) {
      tmp = (function() {
        var ref2, results;
        ref2 = tree.sub;
        results = [];
        for (y in ref2) {
          z = ref2[y];
          results.push(z);
        }
        return results;
      })();
      tmp.sort(function(b, a) {
        return a.pop - b.pop;
      });
      tree.sub = {};
      while (tmp.length) {
        c = tmp.shift();
        tree.sub[c.name] = c;
        c = tmp.pop();
        if (c) {
          tree.sub[c.name] = c;
        }
      }
    }
    results = [];
    for (c in tree.sub) {
      if (tree.sub[c].num !== 0) {
        sub_tree = tree.sub[c];
        sub_tree.conf = sub_tree.conf / sub_tree.num;
        sub_tree.w_conf = sub_tree.w_conf / sub_tree.pop;
        sub_tree.cnt = prev_cnt;
        sub_tree.cum = prev_cum;
        if (sub_tree != null ? sub_tree.gapfill : void 0) {
          delete sub_tree.gapfill;
        }
        out_tree.walk(sub_tree, prev_cnt, prev_cum);
        prev_cnt += sub_tree.num;
        results.push(prev_cum += sub_tree.pop);
      } else {
        results.push(delete tree.sub[c]);
      }
    }
    return results;
  };

  build = function(line) {
    var cur, fields, j, len, prev, ref2, tax_name;
    fields = parse_line(line);
    prev = null;
    cur = out_tree;
    ref2 = fields.tax_names;
    for (i = j = 0, len = ref2.length; j < len; i = ++j) {
      tax_name = ref2[i];
      prev = cur;
      while ((!(tax_name in cur.sub)) || cur.sub[tax_name].gapfill) {
        cur = cur.sub["" + (next_incertae_sedis_name(cur))];
        prev = cur;
        cur.num++;
        cur.conf += fields.tax_pvals[i];
        cur.w_conf += fields.tax_pvals[i] * fields.percent;
        cur.pop += fields.percent;
      }
      cur = cur.sub[tax_name];
      fill_lineage_gap(prev, cur);
      cur.num++;
      cur.conf += fields.tax_pvals[i];
      cur.w_conf += fields.tax_pvals[i] * fields.percent;
      cur.pop += fields.percent;
    }
    return cur.sub[fields.sequence] = {
      pop: fields.percent,
      cum: 0.0,
      cnt: 0,
      num: 1,
      conf: fields.tax_pvals[fields.tax_pvals.length - 1],
      w_conf: fields.percent * fields.tax_pvals[fields.tax_pvals.length - 1],
      level: 7.0,
      length: 1.0,
      name: fields.sequence
    };
  };

  parse_line = function(line) {
    var fields, p, parts, ref2;
    fields = {};
    parts = line.split('\t');
    ref2 = parts.shift().split('_'), fields.sequence = ref2[0], fields.percent = ref2[1];
    fields.percent = parseFloat(fields.percent);
    parts.shift();
    fields.tax_names = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = parts.length; j < len; j += 3) {
        p = parts[j];
        results.push(p.replace(/"/g, '').trim());
      }
      return results;
    })();
    parts.shift();
    fields.tax_levels = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = parts.length; j < len; j += 3) {
        p = parts[j];
        results.push(p.replace(/"/g, '').trim());
      }
      return results;
    })();
    parts.shift();
    fields.tax_pvals = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = parts.length; j < len; j += 3) {
        p = parts[j];
        results.push(parseFloat(p));
      }
      return results;
    })();
    return fields;
  };

  fill_lineage_gap = function(begin, end) {
    var child, cur, insert_name, level, name, ref2, savechild, savename, savesub, sibconf, sibnum, sibpop, sibw_conf;
    if ((begin.level == null) || (end.level == null)) {
      return;
    }
    if (begin.level > end.level) {
      console.error("ERROR: Out of order input tree detected.  Level of " + begin.name + " (" + begin.level + ") > " + end.name + " (" + end.level + ")");
    }
    if (level_after[begin.level] === end.level) {
      return;
    }
    level = level_after[begin.level];
    cur = begin;
    insert_name = next_incertae_sedis_name(begin);
    while (level !== end.level) {
      sibnum = 0;
      sibpop = 0;
      sibw_conf = 0;
      sibconf = 0;
      ref2 = cur.sub;
      for (name in ref2) {
        child = ref2[name];
        sibnum += child.num;
        sibpop += child.pop;
        sibw_conf += child.w_conf;
        sibconf += child.conf;
      }
      savesub = cur.sub;
      cur.sub = {};
      cur.sub[insert_name] = {
        name: insert_name,
        pop: cur.pop - sibpop,
        cum: 0,
        cnt: 0,
        num: cur.num - sibnum,
        conf: cur.conf - sibconf,
        w_conf: cur.w_conf - sibw_conf,
        level: level,
        length: level - cur.level,
        gapfill: true
      };
      for (savename in savesub) {
        savechild = savesub[savename];
        if (savechild.level === level) {
          cur.sub[savename] = savechild;
          delete savesub[savename];
        }
      }
      level = level_after[level];
      cur = cur.sub[insert_name];
      cur.sub = savesub;
    }
    return end.length = end.level - cur.level;
  };

  next_incertae_sedis_name = function(node) {
    var index, next_name;
    index = node.name.indexOf("incertae_sedis");
    if ((index !== -1) && ((node.name.length - index) === "incertae_sedis".length)) {
      next_name = node.name;
    } else {
      next_name = node.name + "_incertae_sedis";
    }
    return next_name;
  };

  filter = function(line_list, minperc) {
    var data, fields, genera, genus, j, len, line, retlines;
    genera = {};
    for (j = 0, len = line_list.length; j < len; j++) {
      line = line_list[j];
      fields = parse_line(line);
      genus = fields.tax_names.pop();
      if (genus in genera) {
        genera[genus].percent += fields.percent;
        genera[genus].lines.push(line);
      } else {
        genera[genus] = {
          percent: fields.percent,
          lines: [line]
        };
      }
    }
    retlines = [];
    for (genus in genera) {
      data = genera[genus];
      if (data.percent >= minperc) {
        Array.prototype.push.apply(retlines, data.lines);
      }
    }
    return retlines;
  };

  pp = function(cur, descend, message) {
    var child, ref2, taxname, taxstring;
    if (message == null) {
      message = "";
    }
    process.stderr.write("************* " + message + "\n");
    taxstring = cur.name + " (" + cur.level + ") (" + cur.pop + ") " + cur.cum + " " + cur.cnt + " " + cur.num;
    ref2 = cur.sub;
    for (taxname in ref2) {
      child = ref2[taxname];
      taxstring += "\n  => " + taxname + " (" + child.level + ") (" + child.pop + ") " + child.cum + " " + child.cnt + " " + child.num;
    }
    process.stderr.write(taxstring + "\n");
    if (descend && (cur != null ? cur.sub : void 0)) {
      return pp(cur.sub[Object.keys(cur.sub)[0]], true, "");
    }
  };

  orig_lines = [];

  process.stdin.on('data', (function() {
    var save;
    save = '';
    return function(c) {
      var lines;
      lines = c.split('\n');
      lines[0] = save + lines[0];
      save = lines.pop();
      return Array.prototype.push.apply(orig_lines, lines);
    };
  })());

  process.stdin.on('end', function() {
    var filtered_lines, j, len;
    filtered_lines = filter(orig_lines, minperc);
    for (j = 0, len = filtered_lines.length; j < len; j++) {
      i = filtered_lines[j];
      if (i) {
        build(i);
      }
    }
    out_tree.walk(out_tree, 0, 0.0);
    process.stderr.write("\n\n");
    process.stdout.write(JSON.stringify(out_tree, null, 1) + "\n");
    return process.exit(0);
  });

}).call(this);
