// Generated by CoffeeScript 1.12.7

/*
 * -------------------------------------------------------------------------- #
 * Center for Environmental Genomics
 * Copyright (C) 2012-2013 University of Washington.
 *
 * Authors:
 * Vaughn Iverson
 * vsi@uw.edu
 * -------------------------------------------------------------------------- #
 * This file is part of SEAStAR.
 *
 * SEAStAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SEAStAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
 * -------------------------------------------------------------------------- #
 */

(function() {
  var end, fn, fs, instream, len, num_parts, part_num, per_read, ref, start, stats, util, ver;

  ver = process.version.slice(1).split('.');

  if (!(ver[1] >= 10 || ver[0] > 0)) {
    console.error("ERROR: nodejs version v0.10.0 or greater required.");
    process.exit(1);
  }

  fs = require('fs');

  util = require('util');

  process.on('uncaughtException', function(err) {
    process.stderr.write("Caught exception: " + err + "\n");
    return process.exit(1);
  });

  ref = process.argv.slice(2, 5), fn = ref[0], num_parts = ref[1], part_num = ref[2];

  num_parts = parseInt(num_parts);

  part_num = parseInt(part_num);

  if (num_parts < 1 || !((0 < part_num && part_num <= num_parts))) {
    process.stderr.write("Error: number of parts must be > 0 and part number(s) must be [1...num_parts]\n");
    process.exit(1);
  }

  len = 0;

  start = 0;

  stats = fs.statSync(fn);

  if (!stats.isFile()) {
    process.stderr.write("Error: Input must be a seekable file.\n");
    process.exit(1);
  } else {
    len = stats.size;
    start = Math.floor(len * (part_num - 1) / num_parts);
    end = Math.floor(len * part_num / num_parts);
    process.stderr.write("Part " + part_num + " of " + num_parts + " of File: " + fn + "\n");
    process.stderr.write("File is " + len + " bytes long, starting at byte " + start + "\n");
  }

  instream = fs.createReadStream(fn, {
    flags: 'r',
    encoding: 'ascii',
    bufferSize: Math.pow(2, 16),
    start: start
  }).on('open', function(fd) {
    return process.stderr.write("Stream opened on file descriptor " + fd + "\n");
  }).on('data', (function() {
    var data_used, save, save_lines;
    save = '';
    save_lines = [];
    data_used = 0;
    return function(c) {
      var j, l, len1, lines, ref1;
      c = save + c;
      lines = c.split('\n');
      lines = save_lines.concat(lines);
      save = lines.pop();
      while (lines.length > 4 && (lines[0][0] !== '@' || lines[2][0] !== '+')) {
        data_used += lines[0].length + 1;
        lines.shift();
      }
      while ((lines.length >= 4) && (start + data_used < end)) {
        ref1 = lines.slice(0, 4);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          l = ref1[j];
          data_used += l.length + 1;
        }
        per_read(lines.splice(0, 4));
      }
      if (start + data_used >= end) {
        process.stderr.write(data_used + " bytes consumed. Should stop at " + end + "\n");
        process.exit(1);
      }
      return save_lines = lines;
    };
  })());

  per_read = function(ra) {
    var i, j, len1, results;
    results = [];
    for (j = 0, len1 = ra.length; j < len1; j++) {
      i = ra[j];
      results.push(process.stdout.write(i + "\n"));
    }
    return results;
  };

}).call(this);
