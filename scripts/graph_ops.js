// Generated by CoffeeScript 1.12.7

/*
 * -------------------------------------------------------------------------- #
 * Center for Environmental Genomics
 * Copyright (C) 2012-2013 University of Washington.
 *
 * Authors:
 * Vaughn Iverson
 * vsi@uw.edu
 * -------------------------------------------------------------------------- #
 * This file is part of SEAStAR.
 *
 * SEAStAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SEAStAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
 * -------------------------------------------------------------------------- #
 *
 * This script reads in a JSON formatted ref_select output graph and performs
 * various transformations on that file.  See the documentation or use the HELP
 * command for additional specific information about each transformation.
 *
 * This script is written in Coffeescript (http://coffeescript.org/) and
 * assumes the node.js (http://nodejs.org/) execution environment.
 *
 * It should be run with additional memory allocated for the V8 javascript engine
 * For example:  node --max-old-space-size=8000 --max-new-space-size=8000 ...
 * (The included graph_ops (and nodewrap) scripts do this automatically)
 * Also, graph_ops has a highly fragmented memory allocation pattern that benefits
 * greatly from the use of node's --always-compact option, which directs the V8
 * Garbage Collector to compact allocated memory on every global sweep. This leads
 * to improved runtimes and avoidance of GC corner-cases that occasionally may
 * lead to stability issues.
 *
 * Usage: [-h|--help] [<input.json[.gz]>] [<script.go[.gz]>] [<command> ['{parms}']...]
 *
 * Where: <input.json> is an optional datafile to initially LOAD
 *        <script.go> is an optional command SCRIPT file
 *        <command> is one of the valid commands
 *        '{params}' optionally specify parameters for a given command
 *        -h for help with running graph_ops
 *
 * Command list:  (type HELP <command> for more details about a given command):
 *
 */

(function() {
  var JSONStream, add_ends, bisect, build_graph_refs, build_removed_graph_refs, calc_ccomps, calc_seq_stats, callback_list, cc_seq_len, check_connections, child_process, circles, clone_object, cmd, cmds, command_file, commands, cut_branches, cut_node, edge_director, err, execute_selection, export_dot, export_fasta, export_table, filter_edges, find_all_ends, find_connection, find_direct_connection, find_ends, find_indirect_connection, find_neighbors, fs, full_order, grab_ccomps, grab_clusts, grab_neighbors, graph_stats, graph_stats_cc, heuristic, len, m, make_directed, maximal_spanning_tree, my_bisect, my_stringify, no_data_str, node_problems, open_output_stream, output_help, path, perform_edits, pop_stash, prev_cmd, process_commands, push_stash, read_input_stream, read_json, ref, relink, remove_graph_refs, remove_leaves, repl, resolve_path, reverse_comp, scaff_link, scaffold, scaffold_spanning_tree, ss_version, start_arg, stash_stack, tetracalc, use_heuristic, ver, write_json, zlib,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  ver = process.version.slice(1).split('.');

  if (!(ver[1] >= 10 || ver[0] > 0)) {
    console.error("ERROR: nodejs version v0.10.0 or greater required.");
    process.exit(1);
  }

  fs = require('fs');

  zlib = require('zlib');

  path = require('path');

  repl = require('repl');

  child_process = require('child_process');

  JSONStream = require('JSONStream');

  ss_version = "SS_BUILD_VERSION";

  no_data_str = "No data, ending SCRIPT processing.";


  /*
   * This array stores the stack of json_graph structures used by the (UN)STASH commands
   */

  stash_stack = [];


  /*
   * This function handles a file path that contains '~', resolving it to the user's HOME dir
   */

  resolve_path = function(fn) {
    if (fn[0] === '~') {
      fn = process.env.HOME + fn.slice(1);
    }
    return fn = path.normalize(fn);
  };


  /*
   * Helper function to uniformly handle reading from a file, a gzipped file or stdin
   */

  read_input_stream = function(fn, parse, cb) {
    var input, inputfn, obj_buffer, read_buffer;
    if (fn === '-') {
      input = process.stdin;
      input.resume();
    } else {
      inputfn = resolve_path(fn);
      if (inputfn.slice(-3) === '.gz') {
        input = fs.createReadStream(inputfn).pipe(zlib.createGunzip());
      } else {
        input = fs.createReadStream(inputfn);
      }
    }
    if (parse) {
      obj_buffer = null;
      return input.pipe(JSONStream.parse()).on('root', function(data) {
        return cb(null, data);
      }).on('error', function(err) {
        console.error("ERROR: JSON read_input_stream could not be opened or parsed '" + fn + "' for input.");
        return cb(err, null);
      });
    } else {
      read_buffer = '';
      return input.on('data', function(data) {
        return read_buffer = read_buffer.concat(data);
      }).on('end', function() {
        return cb(null, read_buffer);
      }).on('error', function(err) {
        console.error("ERROR: read_input_stream could not open file '" + fn + "' for input.");
        return cb(err, null);
      });
    }
  };


  /*
   * Helper function crates an object to uniformly handle writing to a file, a gzipped file or stdout
   * Treat return like a stream, implements on, write and end methods. Smoothes-over the differences
   * between the different output possibilities.
   */

  open_output_stream = function(fn, tag) {
    var error, fout, gz, inc, out, renumber, tag_rep;
    out = {};
    out.on = function(sig, cb) {
      return this.o.on(sig, cb);
    };
    out.write = function(buf, cb) {
      return this.o.write(buf, cb);
    };
    out.end = function(cb) {
      if (this.fh != null) {
        this.o.on("error", function(err) {
          return cb(err);
        });
        this.fh.on("close", function() {
          return setImmediate(cb, null);
        });
        return this.o.end();
      } else {
        return cb(null);
      }
    };
    if (fn) {
      fn = resolve_path(fn);
      if (tag_rep = fn.match(/(@+)/)) {
        if (tag == null) {
          console.warn("ERROR: NULL tag cannot be used for substitution in output file: " + fn);
          return null;
        } else {
          console.warn("INFO: Substituting '" + tag + "' for '" + tag_rep[1] + "' in file " + fn);
          fn = fn.replace(/@+/g, tag);
        }
      }
      if (renumber = fn.match(/([^#]*)(#+)([^#]*)/)) {
        inc = 0;
        renumber[2] = renumber[2].replace(/#/g, '0');
        fn = renumber[1] + renumber[2].slice(inc.toString().length) + inc.toString() + renumber[3];
        while (fs.existsSync(fn)) {
          inc++;
          fn = renumber[1] + renumber[2].slice(inc.toString().length) + inc.toString() + renumber[3];
        }
        console.warn("INFO: Opening numbered file " + fn);
      } else if (fs.existsSync(fn)) {
        console.warn("WARNING: Overwriting file " + fn);
      }
      try {
        fout = fs.createWriteStream(fn);
      } catch (error1) {
        error = error1;
        console.error("ERROR: Could not open file; " + fn);
        return null;
      }
      if (fout) {
        out.fn = fn;
        if (fn.slice(-3) === '.gz') {
          gz = zlib.createGzip();
          gz.pipe(fout);
          out.o = gz;
          out.fh = fout;
        } else {
          out.o = fout;
          out.fh = fout;
        }
      } else {
        out = null;
      }
    } else {
      out.fn = "/dev/stdout";
      out.o = process.stdout;
    }
    return out;
  };

  my_stringify = function(j, o, l, cb) {
    var max_buffer, max_recurse, trav_cnt, traverse;
    if (l == null) {
      l = 2;
    }
    trav_cnt = 0;
    max_buffer = 32000;
    max_recurse = 25;
    traverse = function(stack, o, cb, buf) {
      var k, m, ref, results, work;
      if (buf == null) {
        buf = '';
      }
      trav_cnt++;
      if (work = stack.pop()) {
        if (work.lev && (work.obj instanceof Array)) {
          if (work.keys == null) {
            buf = buf + '[';
            work.keys = (function() {
              results = [];
              for (var m = 0, ref = work.obj.length; 0 <= ref ? m < ref : m > ref; 0 <= ref ? m++ : m--){ results.push(m); }
              return results;
            }).apply(this).reverse();
          } else if (work.keys.length) {
            buf = buf + ',\n';
          }
          if (work.keys.length === 0) {
            buf = buf + ']';
            traverse(stack, o, cb, buf);
          } else {
            k = work.keys.pop();
            stack.push({
              'obj': work.obj,
              'keys': work.keys,
              'lev': work.lev
            }, {
              'obj': work.obj[k],
              'lev': work.lev - 1
            });
            traverse(stack, o, cb, buf);
          }
        } else if (work.lev && (typeof work.obj === 'object')) {
          if (work.keys == null) {
            buf = buf + '{';
            work.keys = Object.keys(work.obj).reverse();
          } else if (work.keys.length) {
            buf = buf + ',\n';
          }
          if (work.keys.length === 0) {
            buf = buf + '}';
            traverse(stack, o, cb, buf);
          } else {
            k = work.keys.pop();
            stack.push({
              'obj': work.obj,
              'keys': work.keys,
              'lev': work.lev
            }, {
              'obj': work.obj[k],
              'lev': work.lev - 1
            });
            buf = buf + ("\"" + k + "\":");
            traverse(stack, o, cb, buf);
          }
        } else {
          buf = buf + JSON.stringify(work.obj);
          if (buf.length > max_buffer || trav_cnt > max_recurse) {
            o.write(buf, function(err) {
              if (err) {
                return cb(err);
              } else {
                return setImmediate(traverse, stack, o, cb);
              }
            });
          } else {
            traverse(stack, o, cb, buf);
          }
        }
      } else {
        o.write(buf + '\n', function(err) {
          if (err) {
            return cb(err);
          } else {
            return setImmediate(cb, null);
          }
        });
      }
      return trav_cnt--;
    };
    return traverse([
      {
        "obj": j,
        "lev": l
      }
    ], o, cb);
  };

  clone_object = function(obj) {
    var clone, i;
    clone = obj instanceof Array ? [] : {};
    for (i in obj) {
      if (typeof obj[i] === "object") {
        clone[i] = clone_object(obj[i]);
      } else {
        clone[i] = obj[i];
      }
    }
    return clone;
  };


  /*
   * Calc_seq_stats calculates the N50, mean %gc and coverage and contig length statistic
   * for the nodes in the passed-in object. It also returns the total length of all sequences
   */

  calc_seq_stats = function(nodes) {
    var cov, gc, l, len, m, n, name, ref, running_total, seq_list, seq_total;
    seq_total = 0;
    seq_list = [];
    cov = 0.0;
    gc = 0.0;
    for (name in nodes) {
      n = nodes[name];
      seq_total += n.seq_len;
      cov += n.cov * n.seq_len;
      gc += ((ref = n.pct_gc) != null ? ref : 0) * n.seq_len;
      seq_list.push(n);
    }
    seq_list.sort(function(a, b) {
      return b.seq_len - a.seq_len;
    });
    running_total = 0;
    for (m = 0, len = seq_list.length; m < len; m++) {
      l = seq_list[m];
      running_total += l.seq_len;
      if (running_total >= seq_total / 2) {
        break;
      }
    }
    return [l.seq_len, seq_total, cov / seq_total, gc / seq_total, seq_list[0].name];
  };


  /*
   * cc_seq_len calculates the total sequence length for all nodes in the provided cc
   */

  cc_seq_len = function(j, cc) {
    var len, m, nid, sum_len;
    sum_len = 0;
    for (m = 0, len = cc.length; m < len; m++) {
      nid = cc[m];
      sum_len += j.nodes[nid].seq_len;
    }
    return sum_len;
  };


  /*
   * Bisect returns a function that when called with an accessor function f,
   * returns a function that takes an array a and a value x, and returns the
   * position in the array where x should be inserted (assuming an ascending
   * sorted array).
   */

  bisect = function(f) {
    return function(a, x, lo, hi) {
      var mid;
      if (arguments.length < 3) {
        lo = 0;
      }
      if (arguments.length < 4) {
        hi = a.length;
      }
      while (lo < hi) {
        mid = lo + hi >> 1;
        if (x < f.call(a, a[mid], mid)) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return lo;
    };
  };


  /*
   * my_bisect is a function to efficiently find a position in an array of elements sorted by score
   */

  my_bisect = bisect(function(d) {
    return d[0].score;
  });


  /*
   * heuristic scoring function that biases bitscores toward edges that connect
   * nodes with similar GC% and Coverage. (Mostly for metagenome assembly)
   */

  use_heuristic = true;

  heuristic = function(a_gc, b_gc, a_cov, b_cov) {
    return (0.08 * Math.abs(a_gc - b_gc)) + (0.125 * Math.abs(Math.log(a_cov, 2) - Math.log(b_cov, 2)));
  };


  /*
   * Setup the internal references between nodes and edges in the graph
   * This function is necessary because the JSON representation of the assembly graph
   * cannot contain any references between sub-objects of the datastructure
   */

  build_graph_refs = function(j, nf, ef) {
    var e, e_out, i, l_in, l_out, len, m, n, n_out, name, s_gc, t_gc;
    if (nf == null) {
      nf = null;
    }
    if (ef == null) {
      ef = null;
    }
    n_out = (function() {
      var ref, results;
      ref = j.nodes;
      results = [];
      for (name in ref) {
        n = ref[name];
        n.id = name;
        n.inlinks = [];
        n.outlinks = [];
        n.links = [];
        if (typeof nf === "function") {
          nf(n);
        }
        results.push(n);
      }
      return results;
    })();
    e_out = (function() {
      var len, m, ref, results;
      ref = j.edges;
      results = [];
      for (i = m = 0, len = ref.length; m < len; i = ++m) {
        e = ref[i];
        if (!(e.src = j.nodes[e.n1])) {
          throw "build_graph_refs: Missing node " + e.n1 + " in edge with " + e.n2 + ".";
        }
        if (!(e.tar = j.nodes[e.n2])) {
          throw "build_graph_refs: Missing node " + e.n2 + " in edge with " + e.n1 + ".";
        }
        if (e.score == null) {
          e.score = e.bits;
          if (use_heuristic) {
            if ((e.src.pct_gc != null) && (e.tar.pct_gc != null)) {
              s_gc = e.src.pct_gc;
              t_gc = e.tar.pct_gc;
            } else {
              s_gc = 0;
              t_gc = 0;
            }
            e.score -= e.bits * heuristic(s_gc, t_gc, e.src.cov, e.tar.cov);
          }
        }
        e.index = i;
        results.push(e);
      }
      return results;
    })();
    e_out.sort(function(a, b) {
      return b.score - a.score;
    });
    for (m = 0, len = e_out.length; m < len; m++) {
      e = e_out[m];
      l_out = [e, e.tar];
      e.src.outlinks.push(l_out);
      e.src.links.push(l_out);
      l_in = [e, e.src];
      e.tar.inlinks.push(l_in);
      e.tar.links.push(l_in);
      if (typeof ef === "function") {
        ef(e);
      }
    }
    return [n_out, e_out];
  };


  /*
   * Setup the internal references between removed nodes and edges in the graph
   * Similar to build_graph_refs above, but works on the "removed" pool of nodes and edges
   * Including connecting them to "selected" nodes
   */

  build_removed_graph_refs = function(j, nf, ef) {
    var e, e_out, i, l_in, l_out, len, m, n, n_out, name, ref, s_gc, t_gc;
    if (nf == null) {
      nf = null;
    }
    if (ef == null) {
      ef = null;
    }
    if (j.removed_nodes == null) {
      j.removed_nodes = {};
    }
    if (j.removed_edges == null) {
      j.removed_edges = [];
    }
    ref = j.nodes;
    for (name in ref) {
      n = ref[name];
      n.rem_inlinks = [];
      n.rem_outlinks = [];
      n.rem_links = [];
      if (typeof nf === "function") {
        nf(n);
      }
    }
    n_out = (function() {
      var ref1, results;
      ref1 = j.removed_nodes;
      results = [];
      for (name in ref1) {
        n = ref1[name];
        n.id = name;
        n.rem_inlinks = [];
        n.rem_outlinks = [];
        n.rem_links = [];
        if (typeof nf === "function") {
          nf(n);
        }
        results.push(n);
      }
      return results;
    })();
    e_out = (function() {
      var len, m, ref1, results;
      ref1 = j.removed_edges;
      results = [];
      for (i = m = 0, len = ref1.length; m < len; i = ++m) {
        e = ref1[i];
        if (!(e.src = j.nodes[e.n1] || j.removed_nodes[e.n1])) {
          throw "build_removed_graph_refs: Missing node " + e.n1 + " in removed edge with " + e.n2 + ".";
        }
        if (!(e.tar = j.nodes[e.n2] || j.removed_nodes[e.n2])) {
          throw "build_removed_graph_refs: Missing node " + e.n2 + " in removed edge with " + e.n1 + ".";
        }
        if (e.score == null) {
          e.score = e.bits;
          if (use_heuristic) {
            if ((e.src.pct_gc != null) && (e.tar.pct_gc != null)) {
              s_gc = e.src.pct_gc;
              t_gc = e.tar.pct_gc;
            } else {
              s_gc = 0;
              t_gc = 0;
            }
            e.score -= e.bits * heuristic(s_gc, t_gc, e.src.cov, e.tar.cov);
          }
        }
        e.index = i;
        results.push(e);
      }
      return results;
    })();
    e_out.sort(function(a, b) {
      return b.score - a.score;
    });
    for (m = 0, len = e_out.length; m < len; m++) {
      e = e_out[m];
      l_out = [e, e.tar];
      e.src.rem_outlinks.push(l_out);
      e.src.rem_links.push(l_out);
      l_in = [e, e.src];
      e.tar.rem_inlinks.push(l_in);
      e.tar.rem_links.push(l_in);
      if (typeof ef === "function") {
        ef(e);
      }
    }
    return [n_out, e_out];
  };


  /*
   * Remove the internal references between nodes and edges in the graph
   * This undoes all of the linking performed by the "build" functions above, leaving the
   * graph datastructure in a state that can be serialized into JSON
   * This function removes references for both selected and removed nodes
   */

  remove_graph_refs = function(j, nf, ef) {
    var e, n, name, ref, ref1;
    if (nf == null) {
      nf = null;
    }
    if (ef == null) {
      ef = null;
    }
    ref = j.nodes;
    for (name in ref) {
      n = ref[name];
      delete n.id;
      delete n.links;
      delete n.inlinks;
      delete n.outlinks;
      delete n.rem_links;
      delete n.rem_inlinks;
      delete n.rem_outlinks;
      if (typeof nf === "function") {
        nf(n);
      }
    }
    j.edges = (function() {
      var len, m, ref1, results;
      ref1 = j.edges;
      results = [];
      for (m = 0, len = ref1.length; m < len; m++) {
        e = ref1[m];
        if (!(e != null)) {
          continue;
        }
        delete e.src;
        delete e.tar;
        delete e.index;
        if (typeof ef === "function") {
          ef(e);
        }
        results.push(e);
      }
      return results;
    })();
    if (j.removed_nodes != null) {
      ref1 = j.removed_nodes;
      for (name in ref1) {
        n = ref1[name];
        delete n.id;
        delete n.links;
        delete n.inlinks;
        delete n.outlinks;
        delete n.rem_links;
        delete n.rem_inlinks;
        delete n.rem_outlinks;
        if (typeof nf === "function") {
          nf(n);
        }
      }
    }
    if (j.removed_edges != null) {
      return j.removed_edges = (function() {
        var len, m, ref2, results;
        ref2 = j.removed_edges;
        results = [];
        for (m = 0, len = ref2.length; m < len; m++) {
          e = ref2[m];
          if (!(e != null)) {
            continue;
          }
          delete e.src;
          delete e.tar;
          delete e.index;
          if (typeof ef === "function") {
            ef(e);
          }
          results.push(e);
        }
        return results;
      })();
    }
  };


  /*
   * Calculate the current set of connected components
   */

  calc_ccomps = function(j, args, callback) {
    var edge_cand, err, l, len, len1, m, n, node, nodes, nodes_added, nodes_avail, ref, u;
    if (args == null) {
      args = {
        "sortby": "nodes"
      };
    }
    if (args.help != null) {
      console.warn(args.help + " -- Calculate the current graph connected components");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n sortby : <string> -- Specify how to sort the resulting list of CCs.  \"nodes\" or \"sequences\"\n \n Example: " + args.help + " {\"sortby\":\"nodes\"} -- Default. Sort CCs in descending\n order of number of nodes.\n \n Example: " + args.help + " {\"sortby\":\"sequences\"} -- Sort CCs in descending order\n of amount of sequence.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.scaffolds != null) {
      console.warn("WARNING: Previous operation changed connected component structure, so existing scaffolds and clusters are being removed.\n");
      delete j.scaffolds;
      if (j.clusters != null) {
        delete j.clusters;
      }
    }
    if (j.removed_nodes == null) {
      j.removed_nodes = {};
    }
    if ((args.sortby != null) && ["nodes", "sequences"].indexOf(args.sortby) === -1) {
      if (typeof callback === "function") {
        callback(new Error('sortby argument must equal either "nodes" or "sequences".'), null);
      }
      return;
    }
    try {
      nodes = build_graph_refs(j)[0];
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    j.connected_comps = [];
    nodes_avail = {};
    for (m = 0, len = nodes.length; m < len; m++) {
      node = nodes[m];
      nodes_avail[node.id] = node;
    }
    n = nodes[0];
    edge_cand = [];
    nodes_added = [];
    while (n) {
      delete nodes_avail[n.id];
      nodes_added.push(n.id);
      ref = n.links;
      for (u = 0, len1 = ref.length; u < len1; u++) {
        l = ref[u];
        if (nodes_avail[l[1].id] != null) {
          edge_cand.push(l);
        }
      }
      l = edge_cand.pop();
      while (l && (nodes_avail[l[1].id] == null)) {
        l = edge_cand.pop();
      }
      if (l) {
        n = l[1];
      } else {
        nodes_added.sort(function(a, b) {
          var lendiff;
          lendiff = j.nodes[b].seq_len - j.nodes[a].seq_len;
          if (lendiff === 0) {
            if (j.nodes[a].id > j.nodes[b].id) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return lendiff;
          }
        });
        j.connected_comps.push(nodes_added);
        nodes_added = [];
        n = nodes.pop();
        while (n && (nodes_avail[n.id] == null)) {
          n = nodes.pop();
        }
      }
    }
    remove_graph_refs(j);
    if (args.sortby === "sequences") {
      j.connected_comps.sort(function(a, b) {
        return cc_seq_len(j, b) - cc_seq_len(j, a);
      });
    } else {
      j.connected_comps.sort(function(a, b) {
        return b.length - a.length;
      });
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
  ## Used to sort out the various types of MP edges and how they orient the underlying contigs
   */

  edge_director = function(prev_n, n, e) {
    var ref, ref1, ref2, ref3, ref4, ref5;
    if (e.dir === "forward" || e.dir === "pos" || e.dir === "contig") {
      return e;
    }
    e.org_dir = e.dir;
    e.p1 = Math.abs(e.p1);
    e.p2 = Math.abs(e.p2);
    switch ([e.dir, prev_n.ref_str, e.n2 === n.id].join("_")) {
      case "FB_true_true":
      case "FB_true_false":
        if ((n.ref_str == null) || n.ref_str) {
          n.ref_str = true;
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      case "FB_false_true":
      case "FB_false_false":
        if ((n.ref_str == null) || !n.ref_str) {
          n.ref_str = false;
          ref = [e.tar.seq_len - e.p2 - 1, e.src.seq_len - e.p1 - 1], e.p1 = ref[0], e.p2 = ref[1];
          ref1 = [e.n2, e.n1], e.n1 = ref1[0], e.n2 = ref1[1];
          ref2 = [e.tar, e.src], e.src = ref2[0], e.tar = ref2[1];
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      case "FF_true_true":
      case "FF_false_false":
      case "BB_true_false":
      case "BB_false_true":
        if ((n.ref_str == null) || n.ref_str === !prev_n.ref_str) {
          n.ref_str = !prev_n.ref_str;
          if (prev_n.ref_str ^ (e.n2 === n.id)) {
            e.p1 = e.src.seq_len - e.p1 - 1;
          } else {
            e.p2 = e.tar.seq_len - e.p2 - 1;
          }
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      case "FF_true_false":
      case "FF_false_true":
      case "BB_true_true":
      case "BB_false_false":
        if ((n.ref_str == null) || n.ref_str === !prev_n.ref_str) {
          n.ref_str = !prev_n.ref_str;
          if (prev_n.ref_str ^ (e.n2 === n.id)) {
            e.p1 = e.src.seq_len - e.p1 - 1;
          } else {
            e.p2 = e.tar.seq_len - e.p2 - 1;
          }
          ref3 = [e.p2, e.p1], e.p1 = ref3[0], e.p2 = ref3[1];
          ref4 = [e.n2, e.n1], e.n1 = ref4[0], e.n2 = ref4[1];
          ref5 = [e.tar, e.src], e.src = ref5[0], e.tar = ref5[1];
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      default:
        return null;
    }
  };


  /*
   * reverse_comp - Reverse complement a sequence
   */

  reverse_comp = function(seq) {
    var rc_tab;
    rc_tab = {
      'A': 'T',
      'T': 'A',
      'G': 'C',
      'C': 'G',
      'X': 'X',
      'M': 'K',
      'K': 'M',
      'R': 'Y',
      'Y': 'R',
      'W': 'S',
      'S': 'W',
      'V': 'B',
      'B': 'V',
      'H': 'D',
      'D': 'H',
      'N': 'N'
    };
    return seq.toUpperCase().split("").reverse().map(function(b) {
      return rc_tab[b];
    }).join("");
  };


  /*
   * Make each connected component a directed graph, properly orienting the
   * nodes relative to each other
   */

  make_directed = function(j) {
    var cc, ccnodes, e, edge_cand, err, l, len, len1, len2, m, max_len, max_node, n, nid, ref, ref1, u, v;
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    ref = j.connected_comps;
    for (m = 0, len = ref.length; m < len; m++) {
      cc = ref[m];
      ccnodes = {};
      edge_cand = [];
      max_len = 0;
      max_node = null;
      for (u = 0, len1 = cc.length; u < len1; u++) {
        nid = cc[u];
        n = j.nodes[nid];
        ccnodes[nid] = n;
        if (n.seq_len > max_len) {
          max_node = n;
          max_len = n.seq_len;
        }
      }
      n = max_node;
      n.ref_str = true;
      while (n) {
        delete ccnodes[n.id];
        ref1 = n.links;
        for (v = 0, len2 = ref1.length; v < len2; v++) {
          l = ref1[v];
          if (!(ccnodes[l[1].id] != null)) {
            continue;
          }
          l.push(n);
          edge_cand.unshift(l);
        }
        l = edge_cand.pop();
        n = null;
        if (l) {
          if (!ccnodes[l[1].id]) {
            throw new Error("make_directed: Cycle detected at node: " + l[1].id);
          }
          n = l[1];
          if (!(e = edge_director(l[2], n, l[0]))) {
            throw new Error("make_directed: Improper edge type detected between nodes: " + n.id + " and " + l[2].id);
          }
          if (!(n.ref_str || (n.seq == null))) {
            n.seq = reverse_comp(n.seq);
          }
        }
      }
    }
    j.digraph = true;
    return remove_graph_refs(j);
  };


  /*
  ## Spanning tree processing using Primm's algorithm
   */

  maximal_spanning_tree = function(j, args, callback) {
    var c, edge_cand, edges_added, err, l, len, len1, links, m, n, new_link, next_n, nodes, nodes_added, nodes_seen, ref, ref1, ref2, u;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Calculate the Maximal Spanning Tree of all connected components");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n bits : true -- Use raw connection bitscores and not GC% / Coverage adjusted bitscores\n \n Example: " + args.help + " {\"bits\":true} -- Use raw connection bitscores from mate-pairing\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.bits) {
      use_heuristic = false;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    if (j.removed_edges == null) {
      j.removed_edges = [];
    }
    try {
      ref = build_graph_refs(j), nodes = ref[0], links = ref[1];
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    edges_added = [];
    ref1 = j.connected_comps;
    for (m = 0, len = ref1.length; m < len; m++) {
      c = ref1[m];
      n = j.nodes[c[0]];
      nodes_added = {};
      nodes_added[n.id] = n;
      nodes_seen = {};
      edge_cand = [];
      while (n) {
        ref2 = n.links;
        for (u = 0, len1 = ref2.length; u < len1; u++) {
          l = ref2[u];
          if (nodes_added[l[1].id] == null) {
            edge_cand.splice(my_bisect(edge_cand, l[0].score), 0, l);
          } else if (l[0].done == null) {
            l[0].done = true;
            j.removed_edges.push(l[0]);
          }
        }
        next_n = edge_cand.pop();
        while (next_n && (nodes_added[next_n[1].id] != null)) {
          if (next_n[0].done == null) {
            next_n[0].done = true;
            j.removed_edges.push(next_n[0]);
          }
          next_n = edge_cand.pop();
        }
        if (next_n) {
          new_link = next_n[0], n = next_n[1];
          nodes_added[n.id] = n;
          edges_added.push(new_link);
          new_link.done = true;
        } else {
          n = null;
        }
      }
    }
    j.edges = edges_added;
    remove_graph_refs(j, null, (function(ed) {
      return delete ed.done;
    }));
    try {
      make_directed(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Scaffolding spanning tree processing, strives to minimize parallel branches when
   * nodes are short relative to pairing insert size
   */

  scaffold_spanning_tree = function(j, args, callback) {
    var c, e, edge_cand, edges_added, err, l, len, len1, len2, len3, links, m, n, new_link, new_territory, next_n, nodes, nodes_added, nodes_seen, ref, ref1, ref2, ref3, ref4, u, v, w;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Calculate the improved Scaffold Spanning Tree of all connected components");
      if (args.detailed_help != null) {
        console.warn("\n NOTE: This command is generally preferable to the MST command when median contig\n length is less than the mean distance between paired reads. That is, when a\n relatively large insert size was selected.\n \n Parameters:\n \n bits : true -- Use raw connection bitscores and not GC% / Coverage adjusted bitscores\n \n Example: " + args.help + " {\"bits\":true} -- Use raw connection bitscores from mate-pairing\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.bits) {
      use_heuristic = false;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    if (j.removed_edges == null) {
      j.removed_edges = [];
    }
    try {
      ref = build_graph_refs(j, function(n) {
        return n.int_mp_bits = 0.0;
      }), nodes = ref[0], links = ref[1];
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    ref1 = j.internal_edges;
    for (m = 0, len = ref1.length; m < len; m++) {
      e = ref1[m];
      if (j.nodes[e.n1] != null) {
        j.nodes[e.n1].int_mp_bits = e.bits;
      }
    }
    new_territory = function(node) {
      var l, len1, next_l, ref2, u;
      next_l = null;
      ref2 = node.links;
      for (u = 0, len1 = ref2.length; u < len1; u++) {
        l = ref2[u];
        if ((nodes_added[l[1].id] == null) && ((nodes_seen[l[1].id] == null) || (l[1].int_mp_bits / l[1].links[0][0].bits > 0.02))) {
          next_l = l;
          break;
        }
      }
      return next_l;
    };
    edges_added = [];
    ref2 = j.connected_comps;
    for (u = 0, len1 = ref2.length; u < len1; u++) {
      c = ref2[u];
      n = j.nodes[c[0]];
      nodes_added = {};
      nodes_added[n.id] = n;
      nodes_seen = {};
      edge_cand = [];
      next_n = true;
      while (next_n) {
        next_n = null;
        new_link = null;
        if (n) {
          ref3 = n.links;
          for (v = 0, len2 = ref3.length; v < len2; v++) {
            l = ref3[v];
            if ((nodes_added[l[1].id] == null) && (!(nodes_seen[l[1].id] != null) || (l[0].score > nodes_seen[l[1].id][0].score))) {
              nodes_seen[l[1].id] = l;
              edge_cand.splice(my_bisect(edge_cand, l[0].score), 0, l);
            } else if (l[0].done == null) {
              l[0].done = true;
              j.removed_edges.push(l[0]);
            }
          }
        }
        next_n = edge_cand.pop();
        while (next_n && (nodes_added[next_n[1].id] != null)) {
          if (next_n[0].done == null) {
            next_n[0].done = true;
            j.removed_edges.push(next_n[0]);
          }
          next_n = edge_cand.pop();
        }
        if (next_n) {
          new_link = next_n[0], n = next_n[1];
          nodes_added[n.id] = n;
          edges_added.push(new_link);
          new_link.done = true;
          if (!new_territory(n)) {
            ref4 = n.links;
            for (w = 0, len3 = ref4.length; w < len3; w++) {
              l = ref4[w];
              if (l[0].done == null) {
                l[0].done = true;
                j.removed_edges.push(l[0]);
              }
            }
            n = null;
          }
        }
      }
    }
    j.edges = edges_added;
    remove_graph_refs(j, (function(nd) {
      return delete nd.int_mp_bits;
    }), (function(ed) {
      return delete ed.done;
    }));
    try {
      make_directed(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Pluck leaves off the tree, the purpose is to remove short branches before pruning
   * to avoid unnecessarily splintering the tree into thousands of branches shorter than
   * the mean pairing insert length
   */

  remove_leaves = function(j, args, callback) {
    var e, edges, edges_kept, err, i, len, len1, len2, m, n, nodes, ref, ref1, ref2, ref3, u, v, w;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Remove all leaf contig nodes (in or outdegree == 0) from the graph");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n iterate : <int> -- number of iterations of " + args.help + " to run. Each is equivalent to\n running " + args.help + " again as a separate command.  By Default <int> = 3\n \n Example: " + args.help + " {\"iterate\":2} -- Equivalent to running: " + args.help + " {\"iterate\":1}\n " + args.help + " {\"iterate\":1}\n \n min_len : <int> -- Minimum length of isolated nodes to keep.\n \n Example: " + args.help + " {\"min_len\":20000} -- Default. Do not \"pluck away\" an\n unconnected node containing 20000 or more bases of sequence. \n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.iterate == null) {
      args.iterate = 3;
    }
    if (args.min_len == null) {
      args.min_len = 20000;
    }
    delete j.connected_comps;
    if (j.removed_edges == null) {
      j.removed_edges = [];
    }
    if (j.removed_nodes == null) {
      j.removed_nodes = {};
    }
    if (j.pluck_iterations == null) {
      j.pluck_iterations = 1;
    }
    for (i = m = ref = j.pluck_iterations, ref1 = args.iterate + j.pluck_iterations - 1; ref <= ref1 ? m <= ref1 : m >= ref1; i = ref <= ref1 ? ++m : --m) {
      try {
        ref2 = build_graph_refs(j), nodes = ref2[0], edges = ref2[1];
      } catch (error1) {
        err = error1;
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      if (i === 1) {
        for (u = 0, len = nodes.length; u < len; u++) {
          n = nodes[u];
          if (!((n.links.length === 0) && ((n.seq_len != null) < args.min_len))) {
            continue;
          }
          j.removed_nodes[n.id] = n;
          delete j.nodes[n.id];
        }
      }
      for (v = 0, len1 = nodes.length; v < len1; v++) {
        n = nodes[v];
        if (!((n.links.length === 1) && (!(ref3 = n.links[0][1].id, indexOf.call(j.removed_nodes, ref3) >= 0)))) {
          continue;
        }
        j.removed_nodes[n.id] = n;
        delete j.nodes[n.id];
      }
      edges_kept = [];
      for (w = 0, len2 = edges.length; w < len2; w++) {
        e = edges[w];
        if ((j.nodes[e.n1] != null) && (j.nodes[e.n2] != null)) {
          edges_kept.push(e);
        } else {
          e.pluck_iteration = i;
          j.removed_edges.push(e);
        }
      }
      j.edges = edges_kept;
      remove_graph_refs(j);
    }
    j.pluck_iterations = args.iterate + j.pluck_iterations - 1;
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Add ends
   */

  add_ends = function(j, args, callback) {
    var c, e, err, head_node, i, len, len1, len2, m, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, tail_node, u, v, w;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Extends scaffold ends (reversing the action of PLUCK at scaffold ends)");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n iterate : <int> -- number of iterations of " + args.help + " to run. Each is equivalent to\n running " + args.help + " again as a separate command.  By Default <int> = 3\n \n Example: " + args.help + " {\"iterate\":2} -- Equivalent of " + args.help + " " + args.help + "\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.iterate == null) {
      args.iterate = 3;
    }
    if (j.pluck_iterations == null) {
      console.warn("WARNING: PUSH called on unPLUCKed graph.");
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.iterate > j.pluck_iterations) {
      args.iterate = j.pluck_iterations;
    }
    for (i = m = ref = j.pluck_iterations, ref1 = j.pluck_iterations - args.iterate + 1; ref <= ref1 ? m <= ref1 : m >= ref1; i = ref <= ref1 ? ++m : --m) {
      if (j.connected_comps == null) {
        calc_ccomps(j);
      }
      try {
        build_graph_refs(j);
        build_removed_graph_refs(j);
      } catch (error1) {
        err = error1;
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      ref2 = j.connected_comps;
      for (u = 0, len = ref2.length; u < len; u++) {
        c = ref2[u];
        try {
          ref3 = find_ends(j, c, true), (ref4 = ref3[0], head_node = ref4[0]), (ref5 = ref3[1], tail_node = ref5[0]);
        } catch (error1) {
          err = error1;
          remove_graph_refs(j, null, (function(e) {
            return delete e.pluck_iteration;
          }));
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        if (!head_node.no_push) {
          ref6 = head_node.rem_inlinks;
          for (v = 0, len1 = ref6.length; v < len1; v++) {
            e = ref6[v];
            if (!(e[0].dir === "forward" && e[0].pluck_iteration === i && (j.nodes[e[0].n1] == null))) {
              continue;
            }
            j.edges.push(e[0]);
            j.nodes[e[1].id] = e[1];
            delete j.removed_nodes[e[1].id];
            delete j.removed_edges[e[0].index];
            break;
          }
        }
        if (!tail_node.no_push) {
          ref7 = tail_node.rem_outlinks;
          for (w = 0, len2 = ref7.length; w < len2; w++) {
            e = ref7[w];
            if (!(e[0].dir === "forward" && e[0].pluck_iteration === i && (j.nodes[e[0].n2] == null))) {
              continue;
            }
            j.edges.push(e[0]);
            j.nodes[e[1].id] = e[1];
            delete j.removed_nodes[e[1].id];
            delete j.removed_edges[e[0].index];
            break;
          }
        }
      }
      if (i !== 1) {
        remove_graph_refs(j);
      }
      delete j.connected_comps;
    }
    remove_graph_refs(j, null, (function(e) {
      return delete e.pluck_iteration;
    }));
    j.pluck_iterations = j.pluck_iterations - args.iterate;
    if (j.pluck_iterations === 0) {
      delete j.pluck_iterations;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
  ## prune the tree by cutting off branches
   */

  cut_branches = function(j, args, callback) {
    var e, edges, edges_kept, err, in_ratio, l, len, len1, len2, len3, m, n, nodes, out_ratio, ref, ref1, ref2, u, v, w;
    if (args == null) {
      args = {
        "verbose": false
      };
    }
    if (args.help != null) {
      console.warn(args.help + " -- Split the assembly graph at all contig nodes with in or out degree > 1");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n strict : true -- always cut all but the strongest link when there are > 2 in+out links\n \n Example: " + args.help + " {\"strict\":false} -- The default case, attempt to determine\n which branch(es) to remove to preserve one high weight path across a multiply\n linked contig node.\n \n Example: " + args.help + " {\"strict\":true} -- Always strictly prune. Equivalent to\n {\"ratio\":0.0} below\n \n ratio : <float> -- ratio of the strongest to next strongest links to trigger strict pruning\n \n Example: " + args.help + " {\"ratio\":0.0} -- Always strictly prune.\n \n Example: " + args.help + " {\"ratio\":1.0} -- Never strictly prune.\n \n Example: " + args.help + " {\"ratio\":0.2} -- Default. Don't strictly filter when the\n score of the highest scoring edge is >= 5x greater than the next highest scoring\n link of the same direction (for both in and outlinks)\n \n verbose : true -- output diagnostics on STDERR\n \n Example: " + args.help + " {\"verbose\":true} -- Generate extra output information\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.strict == null) {
      args.strict = false;
    }
    if (args.ratio == null) {
      args.ratio = 0.2;
    }
    delete j.connected_comps;
    if (j.removed_edges == null) {
      j.removed_edges = [];
    }
    try {
      ref = build_graph_refs(j), nodes = ref[0], edges = ref[1];
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    edges_kept = [];
    for (m = 0, len = nodes.length; m < len; m++) {
      n = nodes[m];
      if (n.inlinks.length > 1) {
        in_ratio = (n.inlinks[1][0].score / n.inlinks[0][0].score) > args.ratio;
        if (args.verbose) {
          console.warn("Inlinks: " + n.name + " " + n.inlinks.length + " " + (n.inlinks[1][0].score / n.inlinks[0][0].score) + " " + in_ratio);
        }
        ref1 = n.inlinks.slice(1);
        for (u = 0, len1 = ref1.length; u < len1; u++) {
          l = ref1[u];
          l[0].remove = true;
        }
      } else {
        in_ratio = false;
      }
      if (n.outlinks.length > 1) {
        out_ratio = (n.outlinks[1][0].score / n.outlinks[0][0].score) > args.ratio;
        if (args.verbose) {
          console.warn("Outlinks: " + n.name + " " + n.outlinks.length + " " + (n.outlinks[1][0].score / n.outlinks[0][0].score) + " " + out_ratio);
        }
        ref2 = n.outlinks.slice(1);
        for (v = 0, len2 = ref2.length; v < len2; v++) {
          l = ref2[v];
          l[0].remove = true;
        }
      } else {
        out_ratio = false;
      }
      if (args.strict && n.inlinks.length && n.outlinks.length && (n.inlinks.length + n.outlinks.length > 2) && (in_ratio || out_ratio)) {
        n.no_push = true;
        if (n.inlinks[0][0].score > n.outlinks[0][0].score) {
          n.outlinks[0][0].remove = true;
          console.warn("Strictly Removing " + n.outlinks[0][0].n1 + " --> " + n.outlinks[0][0].n2);
        } else {
          n.inlinks[0][0].remove = true;
          console.warn("Strictly Removing " + n.inlinks[0][0].n1 + " --> " + n.inlinks[0][0].n2);
        }
      }
    }
    for (w = 0, len3 = edges.length; w < len3; w++) {
      e = edges[w];
      if (e.remove != null) {
        j.removed_edges.push(e);
        delete e.remove;
      } else {
        edges_kept.push(e);
      }
    }
    j.edges = edges_kept;
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
  ## Returns the nodes at the beginning and end of a linear scaffold chain [head, tail] by ccomp
   */

  find_ends = function(j, ccomp, strict) {
    var cn, head_nodes, len, m, tail_nodes;
    if (strict == null) {
      strict = false;
    }
    head_nodes = [];
    tail_nodes = [];
    for (m = 0, len = ccomp.length; m < len; m++) {
      cn = ccomp[m];
      if (j.nodes[cn].inlinks.length === 0) {
        head_nodes.push(j.nodes[cn]);
      }
      if (j.nodes[cn].outlinks.length === 0) {
        tail_nodes.push(j.nodes[cn]);
      }
    }
    if (strict && (head_nodes.length !== 1 || tail_nodes.length !== 1)) {
      throw Error("find_ends: multiple head/tail nodes found in scaffolded CC.");
    }
    return [head_nodes, tail_nodes];
  };


  /*
  ## Returns [head, tail] lists from find_ends() above for all connected components
  ## calculates temporary maximal_spanning_tree() to produce this information, but
  ## restores the global state when done
   */

  find_all_ends = function(j) {
    var c, err, output_list;
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    output_list = (function() {
      var len, m, ref, results;
      ref = j.connected_comps;
      results = [];
      for (m = 0, len = ref.length; m < len; m++) {
        c = ref[m];
        results.push(find_ends(j, c));
      }
      return results;
    })();
    remove_graph_refs(j);
    return output_list;
  };


  /*
   * heuristically remove edges in a linear ccomp that span coverage and/or GC
   * discontinuities
   */

  check_connections = function(j, args, callback) {
    var c, cedges, cnodes, cov_down, cov_up, edge_heuristics, edges_kept, eh, err, gc_down, gc_up, head_node, i, l, len, len1, len_down, len_up, m, max_edge_idx, max_heur, n, ref, split, tot, u;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Break linear scaffolds at a GC / coverage discontinuity");
      if (args.detailed_help != null) {
        console.warn("\n NOTE: Each run of " + args.help + " will break a given scaffold at no more than one\n position. " + args.help + " should be run multiple times if multiple misassemblies\n are suspected.\n \n Parameters:\n \n thresh : <float> -- Threshold used to determine whether or not to break a connection\n \n Example: " + args.help + " '{\"thresh\":0.5}' -- Default. Medium strength heuristic\n score based on GC% / Coverage statistics of a scaffold on either side of a given\n contigs connection edge. The lower the threshold, the more sensitive the filter\n is to such discontinuities.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.thresh == null) {
      args.thresh = 0.5;
    }
    split = true;
    while (split) {
      split = false;
      if (j.connected_comps == null) {
        calc_ccomps(j);
      }
      if (j.removed_edges == null) {
        j.removed_edges = [];
      }
      edges_kept = [];
      try {
        build_graph_refs(j);
      } catch (error1) {
        err = error1;
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      ref = j.connected_comps;
      for (m = 0, len = ref.length; m < len; m++) {
        c = ref[m];
        try {
          head_node = find_ends(j, c, true)[0][0];
        } catch (error1) {
          err = error1;
          remove_graph_refs(j);
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        l = head_node.outlinks[0];
        cnodes = [head_node];
        cedges = [];
        while (l) {
          cnodes.push(l[1]);
          cedges.push(l[0]);
          l = l[1].outlinks[0];
        }
        tot = 0.0;
        len_up = (function() {
          var len1, results, u;
          results = [];
          for (u = 0, len1 = cnodes.length; u < len1; u++) {
            n = cnodes[u];
            results.push(tot += n.seq_len);
          }
          return results;
        })();
        tot = 0.0;
        gc_up = (function() {
          var len1, ref1, results, u;
          results = [];
          for (i = u = 0, len1 = cnodes.length; u < len1; i = ++u) {
            n = cnodes[i];
            results.push((tot += ((ref1 = n.pct_gc) != null ? ref1 : 0) * n.seq_len) / len_up[i]);
          }
          return results;
        })();
        tot = 0.0;
        cov_up = (function() {
          var len1, results, u;
          results = [];
          for (i = u = 0, len1 = cnodes.length; u < len1; i = ++u) {
            n = cnodes[i];
            results.push((tot += n.cov * n.seq_len) / len_up[i]);
          }
          return results;
        })();
        cnodes.reverse();
        tot = 0.0;
        len_down = (function() {
          var len1, results, u;
          results = [];
          for (u = 0, len1 = cnodes.length; u < len1; u++) {
            n = cnodes[u];
            results.push(tot += n.seq_len);
          }
          return results;
        })();
        tot = 0.0;
        gc_down = (function() {
          var len1, ref1, results, u;
          results = [];
          for (i = u = 0, len1 = cnodes.length; u < len1; i = ++u) {
            n = cnodes[i];
            results.push((tot += ((ref1 = n.pct_gc) != null ? ref1 : 0) * n.seq_len) / len_down[i]);
          }
          return results;
        })();
        tot = 0.0;
        cov_down = (function() {
          var len1, results, u;
          results = [];
          for (i = u = 0, len1 = cnodes.length; u < len1; i = ++u) {
            n = cnodes[i];
            results.push((tot += n.cov * n.seq_len) / len_down[i]);
          }
          return results;
        })();
        gc_down.reverse();
        cov_down.reverse();
        edge_heuristics = (function() {
          var ref1, results, u;
          results = [];
          for (i = u = 0, ref1 = cedges.length; 0 <= ref1 ? u < ref1 : u > ref1; i = 0 <= ref1 ? ++u : --u) {
            results.push(heuristic(gc_up[i], gc_down[i + 1], cov_up[i], cov_down[i + 1]));
          }
          return results;
        })();
        max_edge_idx = -1;
        max_heur = -1;
        for (i = u = 0, len1 = edge_heuristics.length; u < len1; i = ++u) {
          eh = edge_heuristics[i];
          if (!(eh > max_heur)) {
            continue;
          }
          max_heur = eh;
          max_edge_idx = i;
        }
        if (max_heur > args.thresh) {
          split = true;
          j.removed_edges.push(cedges.splice(max_edge_idx, 1)[0]);
        }
        edges_kept = edges_kept.concat(cedges);
      }
      j.edges = edges_kept;
      remove_graph_refs(j);
      delete j.connected_comps;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
  ## filter edges from the graph by bitscore
   */

  filter_edges = function(j, args, callback) {
    var e, edges_kept, len, m, ref;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Remove all edges scoring less than thresh bits");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n thresh : <float> -- Bitscore threshold\n \n Example: " + args.help + " {\"thresh\":500.0} -- Default. Remove all edges scoring\n less than 500.0 bits.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.thresh == null) {
      args.thresh = 500.0;
    }
    delete j.connected_comps;
    if (j.removed_edges == null) {
      j.removed_edges = [];
    }
    edges_kept = [];
    ref = j.edges;
    for (m = 0, len = ref.length; m < len; m++) {
      e = ref[m];
      if (e.bits < args.thresh) {
        j.removed_edges.push(e);
      } else {
        edges_kept.push(e);
      }
    }
    j.edges = edges_kept;
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
  ## Output statistics about current graph
   */

  graph_stats = function(j, args, callback) {
    var c, cc, cl, cov, gc, i, i1, ii, len, len1, len2, len3, len4, len5, len6, m, max_node, n50, n_ids, nid, num_nodes, o, p, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, scafnames, seq_tot, sn, u, v, w, y, z;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Generate statistics about the assembly graph");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.txt[.gz]\" -- name of txt format file to write statistics to\n \n Example: " + args.help + " {\"file\":\"my_graph.txt\"} -- Write stats to the file\n my_graph.txt\n \n Example: " + args.help + " {\"file\":\"-\"} -- Default. Write stats to STDOUT\n \n ccdetail : true -- Write connected component details\n \n Example: " + args.help + " {\"ccdetail\":true} -- Equivalent to GCC\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file, args.tag);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.file !== o.fn) {
      args.output = o.fn;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    num_nodes = Object.keys(j.nodes).length;
    o.write("Nodes: " + num_nodes + "\n");
    o.write("Edges: " + j.edges.length + "\n");
    o.write("Internal Edges: " + j.internal_edges.length + "\n");
    o.write("Shared Sequence Edges: " + j.shared_seq_edges.length + "\n");
    if (j.removed_nodes != null) {
      o.write("Removed Nodes: " + (Object.keys(j.removed_nodes).length) + "\n");
    }
    if (j.removed_edges != null) {
      o.write("Removed Edges: " + j.removed_edges.length + "\n");
    }
    if (num_nodes) {
      ref = calc_seq_stats(j.nodes), n50 = ref[0], seq_tot = ref[1], cov = ref[2], gc = ref[3];
      o.write("\nTotal sequence length: " + seq_tot + "  N50: " + n50 + "\n");
      o.write("Mean coverage: " + (cov.toFixed(1)) + "  GC content: " + (gc.toFixed(1)) + "%\n");
    }
    if ((j.removed_nodes != null) && Object.keys(j.removed_nodes).length) {
      ref1 = calc_seq_stats(j.removed_nodes), n50 = ref1[0], seq_tot = ref1[1], cov = ref1[2], gc = ref1[3];
      o.write("\nTotal unselected sequence length: " + seq_tot + "  N50: " + n50 + "\n");
      o.write("Mean unselected coverage: " + (cov.toFixed(1)) + "  GC content: " + (gc.toFixed(1)) + "%\n");
    }
    if ((j.clusters != null) && (j.scaffolds != null)) {
      o.write("\nScaffold Clusters: " + j.clusters.length + "\n");
      if (args.ccdetail != null) {
        o.write("\nScaffold Cluster details: \nclust\tscaffs\tnodes\tseqlen\tcov\t%GC\tn50\tlongest contig\n");
        ref2 = j.clusters;
        for (ii = m = 0, len = ref2.length; m < len; ii = ++m) {
          cl = ref2[ii];
          n_ids = [];
          for (u = 0, len1 = cl.length; u < len1; u++) {
            cc = cl[u];
            n_ids = n_ids.concat(j.scaffolds[cc].nodes);
          }
          ref3 = calc_seq_stats((function() {
            var len2, results, v;
            results = [];
            for (v = 0, len2 = n_ids.length; v < len2; v++) {
              nid = n_ids[v];
              results.push(j.nodes[nid]);
            }
            return results;
          })()), n50 = ref3[0], seq_tot = ref3[1], cov = ref3[2], gc = ref3[3], max_node = ref3[4];
          o.write(ii + "\t" + cl.length + "\t" + n_ids.length + "\t" + seq_tot + "\t" + (cov.toFixed(1)) + "\t" + (gc.toFixed(1)) + "%\t" + n50 + "\t" + max_node + "\n");
          o.write("\n\tScaffold details:\n\tccnum\tnodes\tseqlen\tcov\t%GC\tn50\tlongest contig\tname\n");
          for (v = 0, len2 = cl.length; v < len2; v++) {
            cc = cl[v];
            ref4 = calc_seq_stats((function() {
              var len3, ref4, results, w;
              ref4 = j.scaffolds[cc].nodes;
              results = [];
              for (w = 0, len3 = ref4.length; w < len3; w++) {
                nid = ref4[w];
                results.push(j.nodes[nid]);
              }
              return results;
            })()), n50 = ref4[0], seq_tot = ref4[1], cov = ref4[2], gc = ref4[3], max_node = ref4[4];
            o.write("\t" + j.scaffolds[cc].ccnum + "\t" + j.scaffolds[cc].nodes.length + "\t" + seq_tot + "\t" + (cov.toFixed(1)) + "\t" + (gc.toFixed(1)) + "%\t" + n50 + "\t" + max_node + "\t" + cc + "\n");
          }
          o.write("\n");
        }
      }
    }
    if (j.connected_comps != null) {
      o.write("\nConnected components: " + j.connected_comps.length + "\n");
      if (args.ccdetail != null) {
        o.write("\nConnected component details:\nccnum\tnodes\tseqlen\tcov\t%GC\tn50\tlongest contig");
        if (j.scaffolds != null) {
          o.write("\tscaffold name\n");
          scafnames = [];
          ref5 = j.scaffolds;
          for (sn in ref5) {
            s = ref5[sn];
            scafnames[s.ccnum] = sn;
          }
        } else {
          o.write("\n");
        }
        ref6 = j.connected_comps;
        for (i = w = 0, len3 = ref6.length; w < len3; i = ++w) {
          c = ref6[i];
          ref7 = calc_seq_stats((function() {
            var len4, results, y;
            results = [];
            for (y = 0, len4 = c.length; y < len4; y++) {
              nid = c[y];
              results.push(j.nodes[nid]);
            }
            return results;
          })()), n50 = ref7[0], seq_tot = ref7[1], cov = ref7[2], gc = ref7[3], max_node = ref7[4];
          o.write(i + "\t" + c.length + "\t" + seq_tot + "\t" + (cov.toFixed(1)) + "\t" + (gc.toFixed(1)) + "%\t" + n50 + "\t" + max_node);
          if ((scafnames != null ? scafnames[i] : void 0) != null) {
            o.write("\t" + scafnames[i] + "\n");
          } else {
            o.write("\n");
          }
        }
      }
    }
    o.write("\nProcessing steps completed (command history for this graph):\n");
    ref9 = (ref8 = j.processing) != null ? ref8.slice(0) : void 0;
    for (y = 0, len4 = ref9.length; y < len4; y++) {
      p = ref9[y];
      o.write(p[0] + "\t" + p[1] + "\t" + p[2] + "\t" + (p[3] ? JSON.stringify(p[3]) : void 0) + "\n");
    }
    o.write("\nStash contains " + stash_stack.length + " saved graph" + (stash_stack.length !== 1 ? 's' : '') + ".\n");
    if ((args.ccdetail != null) && stash_stack.length) {
      o.write("\nCommand histories for all stashed graphs (top to bottom of stack)\n");
      stash_stack.reverse();
      for (i = z = 0, len5 = stash_stack.length; z < len5; i = ++z) {
        s = stash_stack[i];
        o.write("\nStack position " + (stash_stack.length - i) + " " + (i === 0 ? '[top]' : '') + (i === stash_stack.length - 1 ? '[bottom]' : '') + ":\n\n");
        ref11 = (ref10 = s.processing) != null ? ref10.slice(0) : void 0;
        for (i1 = 0, len6 = ref11.length; i1 < len6; i1++) {
          p = ref11[i1];
          o.write(p[0] + "\t" + p[1] + "\t" + p[2] + "\t" + (p[3] ? JSON.stringify(p[3]) : void 0) + "\n");
        }
      }
      stash_stack.reverse();
    }
    return o.end(function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };


  /*
  ## Print graph statistics with CC detail and other details
  ## Shortcut equivalent to:  GC {"ccdetail":true}
   */

  graph_stats_cc = function(j, args, callback) {
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Generate statistics about the assembly graph, with details about\n each connected component");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.txt[.gz]\" -- name of txt format file to write statistics to\n \n Example: " + args.help + " {\"file\":\"my_graph_ccs.txt\"} -- Write stats to the file\n my_graph_ccs.txt\n \n Example: " + args.help + " {\"file\":\"-\"} -- Default. Write stats to STDOUT\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    args.ccdetail = true;
    return graph_stats(j, args, callback);
  };


  /*
   * Write DOT output file from active nodes and edges.
   *
   * There is a fair amount of default "style" applied here with a few options.
   *
   * To change styles (or provide alternatives), don't add a lot of code here,
   * rather you should look into the "gvpr" language that comes with the graphviz
   * tools... It is purpose built for re-styling DOT files, etc before rendering.
   */

  export_dot = function(j, args, callback) {
    var doublecircle, edge, edge_type, err, h, len, m, name, node, o, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Write the current assembly graph to the graphviz DOT format");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.dot[.gz]\" -- name of dot format file to write graph to\n \n Example: " + args.help + " {\"file\":\"my_graph.dot\"} -- Write stats to the file\n my_graph.dot\n \n Example: " + args.help + " {\"file\":\"-\"} -- Default. Write graph to STDOUT\n \n detail : true -- Draw labelled contig nodes\n \n Example: " + args.help + " {\"detail\":true} -- Draw contigs as ovals containing\n the node names of each contig. Note that this disables scaling the node size\n by contig length.\n \n arrowtype : \"arrowtype_string\" -- Control the type of arrowheads drawn.\n \n Example: " + args.help + " {\"arrowtype\":\"normal\"} -- Default. Draw normal arrows\n See graphviz documentation at:\n http://www.graphviz.org/doc/info/attrs.html#k:arrowType\n \n pen_scale : <float> -- Control the relative thickness of the arrow lines.\n \n Example: " + args.help + " {\"pen_scale\":0.1} -- Default. Draw normal arrows\n See graphviz documentation at:\n http://www.graphviz.org/doc/info/attrs.html#d:penwidth\n \n const_edge : true -- Draw connection arrow lines at constant width\n \n Example: " + args.help + " {\"const_edge\":true} -- Draw edge arrows of constant width\n regardless of bitscore.\n \n colored_edges : true -- Draw edges colored by the GC% of the connected contigs. Note that\n this overrides any other edge coloring that would have otherwise\n have been applied.\n \n Example: " + args.help + " {\"colored_edges\":true} -- Draw colored arrows\n \n problems : true -- Draw nodes with potential assembly problems as red double circles with\n the node label text inside. Note that this overrides the normal node\n text that would otherwise have been rendered.\n \n Example: " + args.help + " {\"problems\":true} -- Highlight problem nodes\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file, args.tag);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.file !== o.fn) {
      args.output = o.fn;
    }
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.arrowtype == null) {
      args.arrowtype = "normal";
    }
    if (args.pen_scale == null) {
      args.pen_scale = 0.1;
    }
    doublecircle = "shape = \"doublecircle\" style=\"filled\" color = \"red\" penwidth = 3";
    if (j.SEASTAR_version != null) {
      if (j.digraph) {
        o.write("di");
      }
      o.write("graph \"" + ((ref = args.file) != null ? ref : 'Unnamed') + "\" {\n");
      o.write("graph [K = 0.5, repulsiveforce = 1.5, overlap = \"prism\", overlap_scaling = 10000.0 ];\n");
      if (!args.detail) {
        o.write("node [shape=\"point\"];\n");
      } else {
        o.write("node [style=\"filled\"];\n");
      }
      o.write("edge [arrowhead=\"" + args.arrowtype + "\"];\n");
      ref1 = j.nodes;
      for (name in ref1) {
        node = ref1[name];
        h = (((ref2 = node.pct_gc) != null ? ref2 : 0) - 30.0) / 30.0;
        if (h < 0.0) {
          h = 0.0;
        }
        if (h > 1.0) {
          h = 1.0;
        }
        o.write("\"" + name + "\" [bits = " + (((ref3 = node.bits) != null ? ref3 : 0).toFixed(4)) + ", rel_ab = " + (((ref4 = node.rel_ab) != null ? ref4 : 0).toFixed(15)) + ", cov = " + (((ref5 = node.cov) != null ? ref5 : 0).toFixed(4)) + ", cov2 = " + (((ref6 = node.adj_cov) != null ? ref6 : 0).toFixed(4)) + ", uncov = " + ((((ref7 = node.pct_uncov) != null ? ref7 : 0) / 100.0).toFixed(4)) + ", seq_len = " + (((ref8 = node.seq_len) != null ? ref8 : 0).toFixed(0)) + ", rd_len = " + (((ref9 = node.rd_len) != null ? ref9 : 0).toFixed(1)) + ", gc = " + ((((ref10 = node.pct_gc) != null ? ref10 : 0) / 100.0).toFixed(4)) + ", n_shr = " + (((ref11 = node.mp_sh) != null ? ref11 : 0).toFixed(0)) + ", n_bwd = " + (((ref12 = node.mp_bwd) != null ? ref12 : 0).toFixed(0)) + ", n_fwd = " + (((ref13 = node.mp_fwd) != null ? ref13 : 0).toFixed(0)) + ", mp_mean = " + (((ref14 = node.mp_ins_mean) != null ? ref14 : 0).toFixed(4)) + ", mp_stdev = " + (((ref15 = node.mp_ins_stdev) != null ? ref15 : 0).toFixed(4)) + ", mp_sl_pairs = " + (((ref16 = node.mp_pairs) != null ? ref16 : 0).toFixed(0)) + ", name = \"" + name + "\", width = " + (0.01 * Math.sqrt(node.seq_len)) + " fillcolor = \"" + h + ",1.0,0.8\" color = \"" + h + ",1.0,0.5\" label = \"" + (((args.detail === 2) && (node.desc != null)) ? node.desc : name) + "\" " + ((node.contig_problems != null) && args.problems ? doublecircle : "") + " ];\n");
      }
      ref17 = j.edges;
      for (m = 0, len = ref17.length; m < len; m++) {
        edge = ref17[m];
        edge_type = edge.dir === "pos" || edge.dir === "forward" ? "->" : "--";
        if (!args.colored_edges) {
          if (edge.dir === "pos" || edge.interscaffold) {
            o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = DEP, dir = " + edge.dir + ", penwidth = " + (args.pen_scale * Math.sqrt((((!args.const_edge) && (edge.score > 0)) ? edge.score : 5))) + ", color = red ];\n");
          } else {
            o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = MP, dir = " + edge.dir + ", bits = " + (edge.bits.toFixed(3)) + ", score = " + ((ref18 = edge.score) != null ? ref18.toFixed(3) : void 0) + ", pos1 = " + edge.p1 + ", pos2 = " + edge.p2 + ", penwidth = " + (args.pen_scale * Math.sqrt((((!args.const_edge) && (edge.score > 0)) ? edge.score : 1))) + ", arrowsize = " + (0.1 * (Math.log((((!args.const_edge) && (edge.score > 0)) ? edge.score : 1), 2))) + ", color = black ];\n");
          }
        } else {
          h = (((((ref19 = edge.src.pct_gc) != null ? ref19 : 0) + ((ref20 = edge.tar.pct_gc) != null ? ref20 : 0)) / 2) - 30.0) / 30.0;
          if (h < 0.0) {
            h = 0.0;
          }
          if (h > 1.0) {
            h = 1.0;
          }
          if (edge.dir === "pos" || edge.interscaffold) {
            o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = DEP, dir = " + edge.dir + ", penwidth = " + (args.pen_scale * Math.sqrt((((!args.const_edge) && (edge.score > 0)) ? edge.score : 5))) + ", color = \"" + h + ",1.0,0.5\" ];\n");
          } else {
            o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = MP, dir = " + edge.dir + ", bits = " + (edge.bits.toFixed(3)) + ", score = " + ((ref21 = edge.score) != null ? ref21.toFixed(3) : void 0) + ", pos1 = " + edge.p1 + ", pos2 = " + edge.p2 + ", penwidth = " + (args.pen_scale * Math.sqrt((((!args.const_edge) && (edge.score > 0)) ? edge.score : 1))) + ", arrowsize = " + (0.1 * (Math.log((((!args.const_edge) && (edge.score > 0)) ? edge.score : 1), 2))) + ", color = \"" + h + ",1.0,0.5\" ];\n");
          }
        }
      }
      o.write("}\n");
    }
    remove_graph_refs(j);
    return o.end(function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };


  /*
   * FASTA file output
   */

  export_fasta = function(j, args, callback) {
    var err, name, node, o, options, ref, scaf, write_scaffolds;
    if (args == null) {
      args = {
        "verbose": false
      };
    }
    if (args.help != null) {
      console.warn(args.help + " -- Write sequences contained in the current graph data to a FASTA format file.");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.fasta[.gz]\" -- name of FASTA format file to write sequence to\n \n Example: " + args.help + " {\"file\":\"my_seq.fasta\"} -- Write stats to the file\n my_seq.fasta\n \n Example: " + args.help + " {\"file\":\"-\"} -- Default. Write sequence to STDOUT\n \n scaff : true -- Output fully scaffolded sequences (using seq_scaffold tool)\n \n Example: " + args.help + " {\"scaff\":true} -- Output scaffolded contig sequences\n \n NOTE: Using this option as in the above example will run seq_scaffold with its\n default settings.  As an advanced option, this parameter can also accept a string\n argument, which will be passed along to the external seq_scaffold tool as its\n [options] parameter string. Run with --help for help with the settings offered by\n seq_scaffold and the default values.\n \n Example: " + args.help + " {\"scaff\":\"--help\"}\n \n Example: " + args.help + " {\"scaff\":\"--overlap=7 --heal=othercontigs.fna\"}\n \n no_merge_scaffs : true -- Write contig sequences in scaffold order with a scaffold ID in\n each header, ready to be provided to the seq_scaffold tool\n \n Example: " + args.help + " {\"no_merge_scaffs\":true} -- Output ordered contig sequences\n \n abundance : true -- append relative abundance values to the FASTA sequence IDs\n \n Example: " + args.help + " {\"abundance\":true} -- Attach abundances\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.no_merge_scaffs) {
      args.scaff = true;
    }
    if (args.scaff && (j.scaffolds == null)) {
      if (typeof callback === "function") {
        callback(new Error("Can't write scaffolded sequence before the SCAFF command has been run."), null);
      }
      return;
    }
    if (args.stream == null) {
      o = open_output_stream(args.file, args.tag);
    } else {
      o = args.stream;
    }
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        console.error(err);
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.file !== o.fn) {
      args.output = o.fn;
    }
    if (!args.scaff) {
      ref = j.nodes;
      for (name in ref) {
        node = ref[name];
        if (node.seq != null) {
          if (args.abundance != null) {
            o.write(">" + name + "_" + ((node.rel_ab * 100).toFixed(6)) + "\n");
          } else {
            o.write(">" + name + "\n");
          }
          o.write(node.seq + "\n");
        }
      }
      return o.end(function(err) {
        if (err) {
          return typeof callback === "function" ? callback(err, null) : void 0;
        } else {
          return typeof callback === "function" ? callback(null, j) : void 0;
        }
      });
    } else {
      if (j.connected_comps == null) {
        calc_ccomps(j);
      }
      try {
        build_graph_refs(j);
      } catch (error1) {
        err = error1;
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      write_scaffolds = function(out) {
        var nid, ref1, results, scaf, scaf_name;
        ref1 = j.scaffolds;
        results = [];
        for (scaf_name in ref1) {
          scaf = ref1[scaf_name];
          results.push((function() {
            var len, m, ref2, results1;
            ref2 = scaf.nodes;
            results1 = [];
            for (m = 0, len = ref2.length; m < len; m++) {
              nid = ref2[m];
              node = j.nodes[nid];
              if (node.seq != null) {
                out.write(">" + node.id + " " + scaf_name + "\n");
                results1.push(out.write(node.seq + "\n"));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          })());
        }
        return results;
      };
      if (args.no_merge_scaffs) {
        write_scaffolds(o);
        o.end(function(err) {
          if (err) {
            return typeof callback === "function" ? callback(err, null) : void 0;
          } else {
            return typeof callback === "function" ? callback(null, j) : void 0;
          }
        });
      } else {
        if (typeof args.scaff === 'string') {
          options = args.scaff.split(/\s+/);
          options.push('-');
        } else {
          options = ['-'];
        }
        scaf = child_process.spawn('seq_scaffold', options, {});
        scaf.stdout.setEncoding('ascii');
        scaf.stderr.setEncoding('ascii');
        scaf.stdout.on('data', function(data) {
          return o.write(data);
        });
        scaf.stderr.on('data', function(data) {
          return process.stderr.write(data);
        });
        scaf.stdout.on('end', function() {
          return o.end(function(error) {
            if (error) {
              return typeof callback === "function" ? callback(error, null) : void 0;
            } else {
              return typeof callback === "function" ? callback(null, j) : void 0;
            }
          });
        });
        scaf.on('exit', function(code) {
          if (code) {
            console.error('ERROR: ' + code);
            return typeof callback === "function" ? callback(new Error('SEAStAR script "seq_scaffold" could not be executed. Please check that this file is in your PATH.'), null) : void 0;
          }
        });
        write_scaffolds(scaf.stdin);
        scaf.stdin.end();
      }
      return remove_graph_refs(j);
    }
  };


  /*
   * old ref_select style table output
   *
   * This table is used by the 16S abundance pipeline and for doing transcriptomics analysis
   */

  export_table = function(j, args, callback) {
    var name, node, o, ref, ref1;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Write ref_select statistics for selected reference sequences to a TSV file");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.tsv[.gz]\" -- Specify a file name to write the TSV format stats table to.\n If the filename contains one or more '#' characters in a row, these positions are\n replaced with zero-padded digits that will increment each time a file is written to\n this filename pattern. If no '#' characters are present, then this command overwrites\n any existing file of the same name. (See DUMP command an example using this behavior)\n \n Example: " + args.help + " {\"file\":\"my_seq.tsv\"} -- Write stats to the file\n my_seq.tsv\n \n Example: " + args.help + " {\"file\":\"-\"} -- Default. Write stats to STDOUT\n \n header : true -- write a header row with labels for each column\n \n Example: " + args.help + " {\"header\":true} -- Write a header row. The fields are:\n \n bitscore - Information content of reads aligning with the ref sequence\n read_cnt - Number of (possibly fractional) reads aligning with the ref sequence\n norm_cnt - Read_cnt normalized to ref sequence length\n rel_abun - Relative fractional abundance of (copy number of) the ref sequence to\n all selected sequences (those with bitscores above some thresh)\n mean_cov - Mean coverage of the reference sequence by (possibly fractional) reads\n read_len - Mean length of reads aligning with this sequence\n seq_len  - Length of the ref sequence\n pct_gc   - Percent GC content of ref seqeunce (NA if not calculated)\n name     - Catalog name of the ref sequence\n desc     - Catalog description of the ref sequence\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file, args.tag);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.file !== o.fn) {
      args.output = o.fn;
    }
    if (args.header) {
      o.write("id\t bitscore\t read_cnt\t norm_cnt\t rel_abun\t mean_cov\t read_len\t seq_len\t pct_gc\t name\t desc\n");
    }
    ref = j.nodes;
    for (name in ref) {
      node = ref[name];
      o.write(name + "\t " + node.bits + "\t " + node.rd_cnt + "\t " + node.int_cov + "\t " + node.rel_ab + "\t " + node.cov + "\t " + node.rd_len + "\t " + node.seq_len + "\t " + ((ref1 = node.pct_gc) != null ? ref1 : 'NA') + "\t " + node.name + "\t " + node.desc + "\n");
    }
    return o.end(function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };


  /*
   * Reduces the graph to nodes in the object containing node_ids
   * soft = false : Only neighbors of selected nodes are retained as removed. All others are
   *                deleted (along with any edges linking to them).  Default.
   * soft = true  : nodes not selected are moved (along with their edges) to the removed
   *                pool, no data is deleted.
   */

  execute_selection = function(j, nodes, soft) {
    var e, edges_kept, err, id, internal_edges_kept, len, len1, len2, len3, len4, len5, m, n, ref, ref1, ref2, ref3, ref4, ref5, ref6, removed_edges_kept, removed_nodes_kept, shared_edges_kept, u, v, w, y, z;
    if (soft == null) {
      soft = false;
    }
    edges_kept = [];
    removed_edges_kept = [];
    removed_nodes_kept = {};
    internal_edges_kept = [];
    shared_edges_kept = [];
    try {
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (soft) {
      removed_edges_kept = j.removed_edges;
      ref = j.edges;
      for (m = 0, len = ref.length; m < len; m++) {
        e = ref[m];
        if ((nodes[e.n1] != null) && (nodes[e.n2] != null)) {
          edges_kept.push(e);
        } else {
          removed_edges_kept.push(e);
        }
      }
      removed_nodes_kept = j.removed_nodes;
      ref1 = j.nodes;
      for (id in ref1) {
        n = ref1[id];
        if (nodes[id] == null) {
          removed_nodes_kept[id] = n;
        }
      }
    } else {
      for (id in nodes) {
        n = nodes[id];
        ref2 = n.inlinks;
        for (u = 0, len1 = ref2.length; u < len1; u++) {
          e = ref2[u];
          if (nodes[e[1].id] != null) {
            edges_kept.push(e[0]);
          }
        }
        ref3 = n.links;
        for (v = 0, len2 = ref3.length; v < len2; v++) {
          e = ref3[v];
          if (nodes[e[1].id] == null) {
            removed_edges_kept.push(e[0]);
            removed_nodes_kept[e[1].id] = e[1];
          }
        }
        ref4 = n.rem_inlinks;
        for (w = 0, len3 = ref4.length; w < len3; w++) {
          e = ref4[w];
          if (nodes[e[1].id] != null) {
            removed_edges_kept.push(e[0]);
          }
        }
        ref5 = n.rem_links;
        for (y = 0, len4 = ref5.length; y < len4; y++) {
          e = ref5[y];
          if (nodes[e[1].id] == null) {
            removed_edges_kept.push(e[0]);
            removed_nodes_kept[e[1].id] = e[1];
          }
        }
      }
      for (id in removed_nodes_kept) {
        n = removed_nodes_kept[id];
        ref6 = n.rem_inlinks;
        for (z = 0, len5 = ref6.length; z < len5; z++) {
          e = ref6[z];
          if (removed_nodes_kept[e[1].id] != null) {
            removed_edges_kept.push(e[0]);
          }
        }
      }
      j.shared_seq_edges = (function() {
        var i1, len6, ref7, results;
        ref7 = j.shared_seq_edges;
        results = [];
        for (i1 = 0, len6 = ref7.length; i1 < len6; i1++) {
          e = ref7[i1];
          if ((nodes[e.n1] != null) || (nodes[e.n2] != null) || (removed_nodes_kept[e.n1] != null) || (removed_nodes_kept[e.n2] != null)) {
            results.push(e);
          }
        }
        return results;
      })();
      j.internal_edges = (function() {
        var i1, len6, ref7, results;
        ref7 = j.internal_edges;
        results = [];
        for (i1 = 0, len6 = ref7.length; i1 < len6; i1++) {
          e = ref7[i1];
          if ((nodes[e.n1] != null) || (removed_nodes_kept[e.n1] != null)) {
            results.push(e);
          }
        }
        return results;
      })();
    }
    j.nodes = nodes;
    j.edges = edges_kept;
    j.removed_edges = removed_edges_kept;
    j.removed_nodes = removed_nodes_kept;
    return j;
  };


  /*
   * Select ccomps for output or further processing
   *
   * args (mutually exclusive):
   *     ccname = string id of a node to find in a cc
   *     ccnames = list of strings of names to find in multiple
   *     ccnum = number of a cc to select
   *     ccrange = start and end ccnums to select a range e.g. [0,10] or [1,-1]
   *     ccnums = list of numbers of ccs to select
   *     shift = select all but the first ccomp, like [1,-1]
   *     min_nodes = minimum number of nodes in cc
   *     min_seqlen = minimum amount of sequence in nodes in cc
   *     sequence = sequence to search for
   *     soft = move unselected nodes/edges to removed pool, do not delete
   *
   */

  grab_ccomps = function(j, args, callback) {
    var all_seqs, c, cc, ccnums, ci, err, i, i1, id, j1, k1, l1, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, m, m1, n1, new_cclist, new_scaffs, nid, nodes, o1, p1, q1, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, results1, results2, results3, s, sc, seq, sn, u, v, w, y, z;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Select specific connected components for further processing");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n ccname : \"contig_name\" -- Select the connected component containing the named contig\n \n Example: " + args.help + " {\"ccname\":\"NODE_1234\"} -- Select the connected component\n containing the contig named NODE_1234 \n ccnames : [\"contig_name1\",\"contig_name2\",...] -- Select the connected component(s)\n containing the named contigs\n \n Example: " + args.help + " {\"ccnames\":[\"NODE_1234\",\"NODE_5678\"]} -- Select the\n connected components containing the contigs named NODE_1234 and NODE_5678\n \n ccnum : <int> -- Select connected component number <int>\n \n Example: " + args.help + " {\"ccnum\":0} -- Default. Select connected component 0.\n \n ccnums : [<int>,<int>,...] -- Select the connected components from the list of numbers\n \n Example: " + args.help + " {\"ccnums\":[1,2]} -- Select the second and third\n connected components (numbering is zero based)\n \n ccrange : [<int1>,<int2>] -- Select the connected components numbered in the range\n <int1>..<int2> (inclusive). See also: 'shift' option below.\n \n NOTE: <int> may be negative, indicating positions at the end of the list of\n connected components.\n \n Example: " + args.help + " {\"ccrange\":[0,5]} -- Select the first 6 connected\n components\n \n Example: " + args.help + " {\"ccrange\":[-5,-1]} -- Select the last 5 connected\n components\n \n shift : true -- Select all connected components except the first one.\n \n Example: " + args.help + " {\"shift\":true} -- Drop the first connected component.\n \n This is like " + args.help + " {\"ccrange\":[1,-1]} except it doesn't generate a\n fatal error when there is only one remaining connected component, allowing\n processing to potentially continue in any calling SCRIPT commands.\n \n NOTE: The following parameters are \"filters\" that are applied to the set of connected\n components selected by one of the above parameters (or by default, the set of all\n connected components.) These filters may be used in combination, resulting in a logical\n \"AND\" relationship (only connected components satisfying all of the filters are\n selected).\n \n min_nodes : <int> -- Select connected components with <int> or more nodes.\n \n Example: " + args.help + " {\"min_nodes\":2} -- Select connected components\n with 2 or more nodes.\n \n min_seqlen : <int> -- Select connected components with <int> or more sequence within nodes.\n \n Example: " + args.help + " {\"min_seqlen\":1000} -- Select connected components containing\n at least 1000 bases of sequence.\n \n sequence : <string> -- Select connected components containing the provided DNA sequence.\n \n NOTE! This isn't BLAST, the sequence must match exactly. Any differences, including\n ambiguity codes, etc. will prevent matching. The only extra thing that is done is the\n reverse complement of the provided sequence is also searched.\n \n Example: " + args.help + " {\"sequence\":\"AGACTAGCAGATATACGATAACGATACGATACGAT\"}\n Select connected components containing the provided sequence (or its reverse\n complement).\n \n sequences : [<string>, ...] -- Like 'sequence' parameter, but takes a list of sequences.\n \n Example: " + args.help + " {\"sequences\":[\"AGACTAGCAGATATAC\",\"GATAACGATACGATACGAT\"]}\n Select connected components containing any of the provided sequences (or their\n reverse complements).\n \n soft : true -- Determines whether unselected ccomp nodes are deleted or kept as \"removed\"\n \n Example: " + args.help + " {\"soft\":true}\n The contigs of first connected component will remain selected, all others are\n retained as unselected.\n \n Default: " + args.help + " {\"soft\":false}\n The contigs of first connected component will remain selected, neighboring contigs\n (one hop away) are unselected and added to the \"removed\" pool. All others are\n permanently deleted.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    if (args.soft == null) {
      args.soft = false;
    }
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.shift) {
      args.ccrange = [1, -1];
    }
    if (args.ccrange != null) {
      if (args.ccrange[0] < 0) {
        args.ccrange[0] = j.connected_comps.length + args.ccrange[0];
      }
      if (args.ccrange[1] < 0) {
        args.ccrange[1] = j.connected_comps.length + args.ccrange[1];
      }
      args.ccnums = (function() {
        results = [];
        for (var m = ref = args.ccrange[0], ref1 = args.ccrange[1]; ref <= ref1 ? m <= ref1 : m >= ref1; ref <= ref1 ? m++ : m--){ results.push(m); }
        return results;
      }).apply(this);
    } else if (args.ccname != null) {
      ref2 = j.connected_comps;
      for (i = u = 0, len = ref2.length; u < len; i = ++u) {
        c = ref2[i];
        if (!(c.indexOf(args.ccname) !== -1)) {
          continue;
        }
        args.ccnums = [i];
        break;
      }
    } else if (args.ccnames != null) {
      args.ccnums = [];
      ref3 = args.ccnames;
      for (v = 0, len1 = ref3.length; v < len1; v++) {
        id = ref3[v];
        ref4 = j.connected_comps;
        for (i = w = 0, len2 = ref4.length; w < len2; i = ++w) {
          c = ref4[i];
          if (!(c.indexOf(id) !== -1 && args.ccnums.indexOf(i) === -1)) {
            continue;
          }
          args.ccnums.push(i);
          break;
        }
      }
    } else if (args.ccnum != null) {
      args.ccnums = [args.ccnum];
    }
    if (args.sequence) {
      args.sequences = [args.sequence];
    }
    if (args.sequences) {
      ccnums = (ref5 = args.ccnums) != null ? ref5 : (function() {
        results1 = [];
        for (var y = 0, ref6 = j.connected_comps.length; 0 <= ref6 ? y < ref6 : y > ref6; 0 <= ref6 ? y++ : y--){ results1.push(y); }
        return results1;
      }).apply(this);
      args.ccnums = [];
      all_seqs = args.sequences.map(reverse_comp).concat(args.sequences);
      for (z = 0, len3 = ccnums.length; z < len3; z++) {
        i = ccnums[z];
        c = j.connected_comps[i];
        for (i1 = 0, len4 = c.length; i1 < len4; i1++) {
          nid = c[i1];
          if ((seq = j.nodes[nid].seq || '') && !(indexOf.call(args.ccnums, i) >= 0)) {
            for (j1 = 0, len5 = all_seqs.length; j1 < len5; j1++) {
              s = all_seqs[j1];
              if (!(seq.indexOf(s) !== -1)) {
                continue;
              }
              args.ccnums.push(i);
              break;
            }
          }
        }
      }
    }
    if (args.min_nodes != null) {
      ccnums = (ref7 = args.ccnums) != null ? ref7 : (function() {
        results2 = [];
        for (var k1 = 0, ref8 = j.connected_comps.length; 0 <= ref8 ? k1 < ref8 : k1 > ref8; 0 <= ref8 ? k1++ : k1--){ results2.push(k1); }
        return results2;
      }).apply(this);
      args.ccnums = [];
      for (l1 = 0, len6 = ccnums.length; l1 < len6; l1++) {
        i = ccnums[l1];
        if (j.connected_comps[i].length >= args.min_nodes) {
          args.ccnums.push(i);
        }
      }
    }
    if (args.min_seqlen != null) {
      ccnums = (ref9 = args.ccnums) != null ? ref9 : (function() {
        results3 = [];
        for (var m1 = 0, ref10 = j.connected_comps.length; 0 <= ref10 ? m1 < ref10 : m1 > ref10; 0 <= ref10 ? m1++ : m1--){ results3.push(m1); }
        return results3;
      }).apply(this);
      args.ccnums = [];
      for (n1 = 0, len7 = ccnums.length; n1 < len7; n1++) {
        i = ccnums[n1];
        if (cc_seq_len(j, j.connected_comps[i]) >= args.min_seqlen) {
          args.ccnums.push(i);
        }
      }
    }
    if (args.ccnums == null) {
      args.ccnums = [0];
    }
    if (!args.ccnums.length) {
      remove_graph_refs(j);
      console.warn("WARN: SELCC: No connected components found matching selection criteria");
      if (typeof callback === "function") {
        callback(void 0, null);
      }
      return;
    }
    nodes = {};
    new_cclist = [];
    ref11 = args.ccnums;
    for (o1 = 0, len8 = ref11.length; o1 < len8; o1++) {
      cc = ref11[o1];
      if (j.connected_comps[cc] == null) {
        remove_graph_refs(j);
        if (args.shift) {
          if (typeof callback === "function") {
            callback(null, void 0);
          }
        } else {
          if (typeof callback === "function") {
            callback(new Error("Invalid selected ccnum: " + cc + ".  ccnums are zero-based and there are only " + j.connected_comps.length + " ccomps in this graph."), null);
          }
        }
        return;
      }
      new_cclist.push(j.connected_comps[cc]);
      ref12 = j.connected_comps[cc];
      for (p1 = 0, len9 = ref12.length; p1 < len9; p1++) {
        nid = ref12[p1];
        nodes[nid] = j.nodes[nid];
      }
    }
    execute_selection(j, nodes, args.soft);
    j.connected_comps = new_cclist;
    if (j.scaffolds != null) {
      j.connected_comps = new_cclist;
      new_scaffs = {};
      ref13 = j.scaffolds;
      for (sn in ref13) {
        sc = ref13[sn];
        nid = sc.nodes[0];
        ref14 = j.connected_comps;
        for (ci = q1 = 0, len10 = ref14.length; q1 < len10; ci = ++q1) {
          cc = ref14[ci];
          if (!(cc.indexOf(nid) !== -1)) {
            continue;
          }
          sc.ccnum = ci;
          new_scaffs[sn] = sc;
          break;
        }
      }
      j.scaffolds = new_scaffs;
      delete j.clusters;
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Select nodes and neighbors for output or further processing
   */

  find_neighbors = function(nd, r) {
    var l, len, m, n, nodeid_list, ref, ref1;
    nodeid_list = [nd.id];
    nd.seen = true;
    if (r > 0) {
      ref = nd.links;
      for (m = 0, len = ref.length; m < len; m++) {
        ref1 = ref[m], l = ref1[0], n = ref1[1];
        if (!n.seen) {
          nodeid_list = nodeid_list.concat(find_neighbors(n, r - 1));
        }
      }
    }
    return nodeid_list;
  };


  /*
   *   Adds neighboring nodes to the selected list
   *
   * args:
   *     name = string id of a node to find in a cc
   *     names = list of strings of names to find in multiple
   *     radius = number of hops to take searching for neighoring nodes
   *     sequence = DNA sequence to search for.
   */

  grab_neighbors = function(j, args, callback) {
    var all_seqs, err, len, len1, len2, m, n, name, nid, nodes, ref, ref1, ref2, ref3, revseq, s, seq, u, v;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Select contigs from the connected neighborhood(s) of the given contig(s)");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n name : \"contig_name\" -- Use a single contig by name\n \n Example: " + args.help + " {\"name\":\"NODE_1234\"} -- Select NODE_1234 (and its\n neighbors)\n \n names : [\"contig_name1\",\"contig_name2\",...] -- Use multiple contigs by name\n \n Example: " + args.help + " {\"names\":[\"NODE_1234\",\"NODE_5678\"]} -- Select these\n two contigs (and their neighbors...)\n \n radius : <int> -- Size of the neighborhood of contigs to select\n \n Example: " + args.help + " {\"radius\":2} -- Select all neighbors and neighbors of\n neighbors\n \n Example: " + args.help + " {\"radius\":0} -- Default. Select only the named contig(s)\n \n sequence : <string> -- Select contig(s) found to contain the provided DNA sequence.\n \n NOTE! This isn't BLAST, the sequence must match exactly. Any differences, including\n ambiguity codes, etc. will prevent matching. The only extra thing that is done is the\n reverse complement of the provided sequence is also searched.\n \n Example: " + args.help + " {\"sequence\":\"AGACTAGCAGATATACGATAACGATACGATACGAT\"}\n Select contig(s) containing the provided sequence (or its reverse complement).\n \n sequences : [<string>, ...] -- Like 'sequence' parameter, but takes a list of sequences.\n \n Example: " + args.help + " {\"sequences\":[\"AGACTAGCAGATATAC\",\"GATAACGATACGATACGAT\"]}\n Select contigs containing any of the provided sequences (or their reverse\n complements).\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.name != null) {
      args.names = [args.name];
    }
    if (args.sequence) {
      args.sequences = [args.sequence];
    }
    if (args.sequences) {
      args.names = [];
      all_seqs = args.sequences.map(reverse_comp).concat(args.sequences);
      ref = j.nodes;
      for (nid in ref) {
        n = ref[nid];
        if (seq = n.seq || '') {
          for (m = 0, len = all_seqs.length; m < len; m++) {
            s = all_seqs[m];
            if (!(seq.indexOf(s) !== -1)) {
              continue;
            }
            args.names.push(nid);
            break;
          }
        }
      }
    }
    if (args.sequence) {
      args.names = [];
      revseq = reverse_comp(args.sequence);
      ref1 = j.nodes;
      for (nid in ref1) {
        n = ref1[nid];
        if (seq = n.seq || '') {
          if (seq.indexOf(args.sequence) !== -1 || seq.indexOf(revseq) !== -1) {
            args.names.push(nid);
          }
        }
      }
    }
    if (!args.names) {
      console.warn("WARN: SELND: No nodes found matching selection criteria");
      if (typeof callback === "function") {
        callback(void 0, null);
      }
      return;
    }
    if (args.radius == null) {
      args.radius = 0;
    }
    nodes = {};
    ref2 = args.names;
    for (u = 0, len1 = ref2.length; u < len1; u++) {
      name = ref2[u];
      ref3 = find_neighbors(j.nodes[name], args.radius);
      for (v = 0, len2 = ref3.length; v < len2; v++) {
        nid = ref3[v];
        nodes[nid] = j.nodes[nid];
      }
    }
    execute_selection(j, nodes);
    remove_graph_refs(j, function(n) {
      return delete n.seen;
    });
    delete j.connected_comps;
    if (j.scaffolds != null) {
      delete j.scaffolds;
    }
    if (j.clusters != null) {
      delete j.clusters;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Functions for finding connections between scaffold ends
   */

  find_direct_connection = function(head, tail, thresh) {
    var edge, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, select_edge, select_head, select_tail, try_dir_links;
    if (thresh == null) {
      thresh = 0;
    }
    try_dir_links = function(h, t) {
      var e, l, len, m, ref;
      e = null;
      if (h && t) {
        ref = h.rem_links;
        for (m = 0, len = ref.length; m < len; m++) {
          l = ref[m];
          if (l[1].id === t.id && (e = edge_director(t, h, l[0])) && t.id === e.n1) {
            break;
          } else {
            e = null;
          }
        }
      }
      if (e) {
        return [e];
      } else {
        return null;
      }
    };
    select_edge = null;
    select_head = null;
    select_tail = null;
    if ((edge = try_dir_links(head, tail)) && (((ref = edge[0]) != null ? ref.bits : void 0) > thresh || ((ref1 = edge[0]) != null ? ref1.dir : void 0) === "contig")) {
      select_head = head;
      select_tail = tail;
      select_edge = edge;
      thresh = edge[0].bits;
    }
    if ((edge = try_dir_links((ref2 = head.outlinks[0]) != null ? ref2[1] : void 0, tail)) && ((ref3 = edge[0]) != null ? ref3.bits : void 0) > thresh) {
      select_head = head.outlinks[0][1];
      select_tail = tail;
      select_edge = edge;
      thresh = edge[0].bits;
    }
    if ((edge = try_dir_links(head, (ref4 = tail.inlinks[0]) != null ? ref4[1] : void 0)) && ((ref5 = edge[0]) != null ? ref5.bits : void 0) > thresh) {
      select_head = head;
      select_tail = tail.inlinks[0][1];
      select_edge = edge;
      thresh = edge[0].bits;
    }
    if ((edge = try_dir_links((ref6 = head.outlinks[0]) != null ? ref6[1] : void 0, (ref7 = tail.inlinks[0]) != null ? ref7[1] : void 0)) && ((ref8 = edge[0]) != null ? ref8.bits : void 0) > thresh) {
      select_head = head.outlinks[0][1];
      select_tail = tail.inlinks[0][1];
      select_edge = edge;
      thresh = edge[0].bits;
    }
    return [select_edge, select_head, select_tail, thresh];
  };


  /*
   * Look for indirect connections (via another node not part of either scaffold)
   */

  find_indirect_connection = function(head, tail, thresh) {
    var ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, result, select_head, select_result, select_tail, try_indir_links;
    if (thresh == null) {
      thresh = 0;
    }
    try_indir_links = function(h, t) {
      var eh, et, hnodes, l, len, len1, m, ref, ref1, u;
      et = null;
      eh = null;
      if (h && t) {
        hnodes = {};
        ref = h.rem_links;
        for (m = 0, len = ref.length; m < len; m++) {
          l = ref[m];
          hnodes[l[1].id] = l;
        }
        ref1 = t.rem_links;
        for (u = 0, len1 = ref1.length; u < len1; u++) {
          l = ref1[u];
          if (hnodes[l[1].id] != null) {
            if ((et = edge_director(t, l[1], l[0])) && (t.id === et.n1) && (eh = edge_director(hnodes[l[1].id][1], h, hnodes[l[1].id][0])) && (h.id === eh.n2)) {
              break;
            } else {
              et = null;
              eh = null;
            }
          }
        }
        if (et && eh) {
          return [et, eh];
        } else {
          return null;
        }
      }
    };
    select_result = null;
    select_head = null;
    select_tail = null;
    if ((result = try_indir_links((ref = head.outlinks[0]) != null ? ref[1] : void 0, (ref1 = tail.inlinks[0]) != null ? ref1[1] : void 0)) && (result != null ? (ref2 = result[0]) != null ? ref2.bits : void 0 : void 0) > thresh && (result != null ? (ref3 = result[1]) != null ? ref3.bits : void 0 : void 0) > thresh) {
      select_head = head.outlinks[0][1];
      select_tail = tail.inlinks[0][1];
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    if ((result = try_indir_links(head, (ref4 = tail.inlinks[0]) != null ? ref4[1] : void 0)) && (result != null ? (ref5 = result[0]) != null ? ref5.bits : void 0 : void 0) > thresh && (result != null ? (ref6 = result[1]) != null ? ref6.bits : void 0 : void 0) > thresh) {
      select_head = head;
      select_tail = tail.inlinks[0][1];
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    if ((result = try_indir_links((ref7 = head.outlinks[0]) != null ? ref7[1] : void 0, tail)) && (result != null ? (ref8 = result[0]) != null ? ref8.bits : void 0 : void 0) > thresh && (result != null ? (ref9 = result[1]) != null ? ref9.bits : void 0 : void 0) > thresh) {
      select_head = head.outlinks[0][1];
      select_tail = tail;
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    if ((result = try_indir_links(head, tail)) && (result != null ? (ref10 = result[0]) != null ? ref10.bits : void 0 : void 0) > thresh && (result != null ? (ref11 = result[1]) != null ? ref11.bits : void 0 : void 0) > thresh) {
      select_head = head;
      select_tail = tail;
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    return [select_result, select_head, select_tail, thresh];
  };


  /*
   * Look for both direct and indirect connections
   */

  find_connection = function(head, tail, thresh) {
    var direct, indirect, ref, ref1;
    if (thresh == null) {
      thresh = 0;
    }
    direct = find_direct_connection(head, tail, thresh);
    if (((ref = direct[0]) != null ? (ref1 = ref[0]) != null ? ref1.dir : void 0 : void 0) !== "contig") {
      console.warn("Trying indirect: " + head.name + " -- " + tail.name);
      if (direct[0]) {
        thresh = direct[3];
      }
      indirect = find_indirect_connection(head, tail, thresh);
      if (indirect[0]) {
        return indirect;
      } else {
        return direct;
      }
    } else {
      return direct;
    }
  };


  /*
   * Circle detect
   */

  circles = function(j, args, callback) {
    var c, cc, circle_ccs, e, edge, edge_head, edge_tail, edit_work, err, good_scaffs, head_node, i, inlink_nodes, len, len1, len2, len3, len4, m, name, new_head, new_tail, outlink_nodes, preexisting, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, relink_nodes, remove_head_node, remove_tail_node, s, scaff, sn, split_pos, tail_node, u, v, w, y;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Find circular sequences among scaffolds");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n circular : true -- return circularized scaffolds\n \n Example: " + args.help + " {\"circular\":true} -- Produce circular scaffolds.\n \n Default (false): Produce linear scaffolds placing the ends within the largest\n contig of each connected component. The node with the longest sequence will be\n divided equally into two and the mate-pair connections also divided, such that\n they form two clean ends for the new scaffold.\n \n thresh : <float> -- minimum bitscore of end-connecting pairing information\n \n Example: " + args.help + " {\"thresh\":0.0} -- Default. Circle completing end\n connections must have a positive bit score to qualify\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.circular == null) {
      args.circular = false;
    }
    if (args.thresh == null) {
      args.thresh = 0.0;
    }
    if (args.min_nodes == null) {
      args.min_nodes = 3;
    }
    if (args.min_seqlen == null) {
      args.min_seqlen = 10000;
    }
    grab_ccomps(j, {
      'min_seqlen': args.min_seqlen,
      'min_nodes': args.min_nodes
    });
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    circle_ccs = [];
    preexisting = {};
    remove_head_node = function(hn, jj, cc) {
      jj.removed_edges.push(hn.outlinks[0][0]);
      delete jj.edges[hn.outlinks[0][0].index];
      cc.splice(cc.indexOf(hn.id), 1);
      return hn.outlinks[0][1];
    };
    remove_tail_node = function(tn, jj, cc) {
      jj.removed_edges.push(tn.inlinks[0][0]);
      delete jj.edges[tn.inlinks[0][0].index];
      cc.splice(cc.indexOf(tn.id), 1);
      return tn.inlinks[0][1];
    };
    ref = j.connected_comps;
    for (i = m = 0, len = ref.length; m < len; i = ++m) {
      c = ref[i];
      try {
        ref1 = find_ends(j, c, true), (ref2 = ref1[0], head_node = ref2[0]), (ref3 = ref1[1], tail_node = ref3[0]);
      } catch (error1) {
        err = error1;
        remove_graph_refs(j);
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      console.warn("Trying: " + head_node.id + " " + tail_node.id);
      ref4 = find_connection(head_node, tail_node, args.thresh), e = ref4[0], new_head = ref4[1], new_tail = ref4[2];
      if (e) {
        if (e.length === 1) {
          edge = e[0];
          console.warn("Found edge: " + edge.dir);
          if (edge.dir === "contig") {
            console.warn("Found existing circle in CC_" + i + ".  Largest node: " + c[0]);
            preexisting[c[0]] = true;
            circle_ccs.push(i);
            if (args.circular) {
              j.edges.push(edge);
              delete j.removed_edges[edge.index];
            }
          } else {
            console.warn("Found potential circle in CC_" + i);
            if (new_head !== head_node) {
              head_node = remove_head_node(head_node, j, c);
            }
            if (new_tail !== tail_node) {
              tail_node = remove_tail_node(tail_node, j, c);
            }
            if (head_node !== tail_node && new_head === head_node && new_tail === tail_node) {
              edge.circle_connect = true;
              j.edges.push(edge);
              delete j.removed_edges[edge.index];
              circle_ccs.push(i);
            } else {
              console.warn("CIRCLE: Strange case in Direct Connection: " + head_node.id + " -- " + tail_node.id);
            }
          }
        } else {
          if (new_head !== head_node) {
            head_node = remove_head_node(head_node, j, c);
          }
          if (new_tail !== tail_node) {
            tail_node = remove_tail_node(tail_node, j, c);
          }
          if (head_node !== tail_node && new_head === head_node && new_tail === tail_node) {
            edge_tail = e[0], edge_head = e[1];
            edge_tail.circle_connect = true;
            edge_head.circle_connect = true;
            j.edges.push(edge_tail);
            delete j.removed_edges[edge_tail.index];
            j.nodes[edge_head.n1] = edge_head.src;
            delete j.removed_nodes[edge_head.n1];
            c.push(edge_head.n1);
            j.edges.push(edge_head);
            delete j.removed_edges[edge_head.index];
            if ((j.nodes[edge_head.n1] != null)) {
              console.warn("CIRCLE: Indirect connection node: " + j.nodes[edge_head.n1].id + " is placed in another scaffold.");
            }
            circle_ccs.push(i);
          } else {
            console.warn("CIRCLE: Strange case in Indirect Connection: " + head_node.id + " -- " + tail_node.id);
          }
        }
      }
    }
    remove_graph_refs(j);
    if (circle_ccs.length) {
      console.warn(circle_ccs.length + " circles still in play.");
      grab_ccomps(j, {
        'ccnums': circle_ccs
      });
      console.warn("After select: " + j.connected_comps.length + " ccomps.");
      if (args.circular) {
        delete j.scaffolds;
      } else {
        relink_nodes = ((function() {
          var len1, ref5, results, u;
          if (!preexisting[c[0]]) {
            ref5 = j.connected_comps;
            results = [];
            for (u = 0, len1 = ref5.length; u < len1; u++) {
              c = ref5[u];
              results.push(c[0]);
            }
            return results;
          }
        })());
        if (relink_nodes) {
          console.warn("#Relinking...", JSON.stringify(relink_nodes));
          relink(j, {
            "names": relink_nodes,
            "complete": false,
            "existing": false
          });
        }
        calc_ccomps(j);
        try {
          build_graph_refs(j);
        } catch (error1) {
          err = error1;
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        edit_work = [];
        console.warn("Preexisting circles: ", JSON.stringify(preexisting));
        ref5 = j.connected_comps;
        for (i = u = 0, len1 = ref5.length; u < len1; i = ++u) {
          cc = ref5[i];
          sn = j.nodes[cc[0]];
          if (preexisting[cc[0]]) {
            console.warn("FOUND: " + cc[0]);
          } else {
            split_pos = Math.round(sn.seq_len / 2);
            console.warn("Splitting largest node: " + sn.name + " length: " + sn.seq_len + ", split at: " + split_pos);
            inlink_nodes = {};
            ref6 = sn.inlinks;
            for (v = 0, len2 = ref6.length; v < len2; v++) {
              e = ref6[v];
              inlink_nodes[e[1].id] = true;
            }
            outlink_nodes = [];
            ref7 = sn.outlinks;
            for (w = 0, len3 = ref7.length; w < len3; w++) {
              e = ref7[w];
              if (ref8 = e[1].id, indexOf.call(inlink_nodes, ref8) < 0) {
                outlink_nodes.push(e[1].id);
              } else {
                delete inlink_nodes[e[1].id];
              }
            }
            inlink_nodes = Object.keys(inlink_nodes);
            edit_work.push([sn.name, split_pos, inlink_nodes, outlink_nodes]);
          }
        }
        remove_graph_refs(j);
        for (i = y = 0, len4 = edit_work.length; y < len4; i = ++y) {
          ref9 = edit_work[i], name = ref9[0], split_pos = ref9[1], inlink_nodes = ref9[2], outlink_nodes = ref9[3];
          cc = j.connected_comps[i];
          cut_node(j, {
            "name": name,
            "new_name": name + "_splitA",
            "end": split_pos - 1,
            "include": inlink_nodes
          });
          j.nodes[name + "_splitA"].circle_end = true;
          cut_node(j, {
            "name": name,
            "new_name": name + "_splitB",
            "begin": split_pos,
            "include": outlink_nodes
          });
          j.nodes[name + "_splitB"].circle_begin = true;
          perform_edits(j, {
            "rem_nodes": [name]
          });
          cc.shift();
          cc.push(name + "_splitA");
          cc.push(name + "_splitB");
          j.removed_edges.push({
            n1: name + "_splitA",
            n2: name + "_splitB",
            dir: "contig",
            score: 0.0
          });
        }
        remove_graph_refs(j);
        console.warn("Rescaffolding circles.");
        scaffold(j);
        console.warn("Verifying scaffolds " + (Object.keys(j.scaffolds).length));
        good_scaffs = [];
        ref10 = j.scaffolds;
        for (s in ref10) {
          scaff = ref10[s];
          if (j.nodes[scaff.nodes[0]].circle_begin && j.nodes[scaff.nodes[scaff.nodes.length - 1]].circle_end) {
            good_scaffs.push(scaff.ccnum);
          }
        }
        console.warn("Good scaffolds remaining: " + good_scaffs.length);
        if (good_scaffs.length) {
          grab_ccomps(j, {
            'ccnums': good_scaffs
          });
          console.warn("Done processing circles.");
        } else {
          console.warn("CIRCLE command produced no output. (No circles found)");
          if (typeof callback === "function") {
            callback(null, void 0);
          }
          return;
        }
      }
    } else {
      console.warn("CIRCLE command produced no output. (No circles found)");
      if (typeof callback === "function") {
        callback(null, void 0);
      }
      return;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Scaffold end-link
   */

  scaff_link = function(j, args, callback) {
    var c, cc, e, e1, e2, edge_cache, err, find_node_scaff, h1, h2, len, len1, len2, m, ref, ref1, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, scaffolds, scaffolds2, sl, ss, ssl, t1, t2, u, v;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Find connections linking scaffold ends");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n scaff_names : [\"Scaffold_name1\",\"Scaffold_name2\",...] -- Select the scaffolds\n to attempt to link to each other. Default: use all scaffolds.\n \n Example: " + args.help + " {\"scaff_names\":[\"Scaffold_1234\",\"Scaffold_5678\"]}\n -- Select the scaffolds named Scaffold_1234 and Scaffold_5678 for processing.\n \n exclusive : true -- Only look for connections within the scaff_names list.\n Default: look for connections between those in scaff_names and all other scaffolds.\n \n Example: " + args.help + " {\"exclusive\":true,\"scaff_names\":[\"Scaffold_1234\",\"Scaffold_5678\"]}\n -- Only look for connections between Scaffold_1234 and Scaffold_5678.\n \n thresh : <float> -- Bitscore threshold\n \n Example: " + args.help + " {\"thresh\":1000.0}' -- Default. Only reconnect scaffold\n ends with connections scoring at least 1000.0 bits\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.thresh == null) {
      args.thresh = 1000.0;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.scaff_names != null) {
      scaffolds = {};
      ref = args.scaff_names;
      for (m = 0, len = ref.length; m < len; m++) {
        s = ref[m];
        if (j.scaffolds[s] != null) {
          scaffolds[s] = j.scaffolds[s];
        }
      }
    } else {
      scaffolds = j.scaffolds;
    }
    if (args.exclusive) {
      scaffolds2 = scaffolds;
    } else {
      scaffolds2 = j.scaffolds;
    }
    find_node_scaff = function(n) {
      var scaff, scafflst;
      for (scaff in scaffolds2) {
        scafflst = scaffolds2[scaff];
        if (indexOf.call(scafflst.nodes, n) >= 0) {
          return scaff;
        }
      }
      return null;
    };
    for (s in scaffolds) {
      sl = scaffolds[s];
      edge_cache = [];
      for (ss in scaffolds2) {
        ssl = scaffolds2[ss];
        if (!((sl.ccnum >= ssl.ccnum) || !((scaffolds2 === scaffolds) || (ss in scaffolds)))) {
          continue;
        }
        c = j.connected_comps[sl.ccnum];
        cc = j.connected_comps[ssl.ccnum];
        if (!args.full_length) {
          try {
            ref1 = find_ends(j, c, true), (ref2 = ref1[0], h1 = ref2[0]), (ref3 = ref1[1], t1 = ref3[0]);
            ref4 = find_ends(j, cc, true), (ref5 = ref4[0], h2 = ref5[0]), (ref6 = ref4[1], t2 = ref6[0]);
          } catch (error1) {
            err = error1;
            remove_graph_refs(j);
            if (typeof callback === "function") {
              callback(err, null);
            }
            return;
          }
          e1 = find_connection(h1, t2, args.thresh)[0];
          if (e1) {
            if (e1.length === 1) {
              if (!e1[0].interscaffold) {
                e1[0].interscaffold = true;
                j.edges.push(e1[0]);
                delete j.removed_edges[e1[0].index];
              }
              console.warn(ss + " " + e1[0].n1 + " --> " + s + " " + e1[0].n2 + " -- " + e1[0].bits + " bits");
            } else {
              if (!e1[0].interscaffold) {
                e1[0].interscaffold = true;
                j.edges.push(e1[0]);
                delete j.removed_edges[e1[0].index];
              }
              if (!e1[1].interscaffold) {
                e1[1].interscaffold = true;
                j.edges.push(e1[1]);
                delete j.removed_edges[e1[1].index];
              }
              if (j.nodes[e1[1].n1] == null) {
                j.nodes[e1[1].n1] = e1[1].src;
                delete j.removed_nodes[e1[1].n1];
              }
              console.warn(ss + " " + e1[0].n1 + " --> " + (find_node_scaff(e1[1].n1)) + " " + e1[1].n1 + " --> " + s + " " + e1[1].n2 + " -- " + e1[0].bits + " + " + e1[1].bits + " bits");
            }
          }
          if (s !== ss) {
            e2 = find_connection(h2, t1, args.thresh)[0];
            if (e2) {
              if (e2.length === 1) {
                if (!e2[0].interscaffold) {
                  e2[0].interscaffold = true;
                  j.edges.push(e2[0]);
                  delete j.removed_edges[e2[0].index];
                }
                console.warn(s + " " + e2[0].n1 + " --> " + ss + " " + e2[0].n2 + " -- " + e2[0].bits + " bits");
              } else {
                if (!e2[0].interscaffold) {
                  e2[0].interscaffold = true;
                  j.edges.push(e2[0]);
                  delete j.removed_edges[e2[0].index];
                }
                if (!e2[1].interscaffold) {
                  e2[1].interscaffold = true;
                  j.edges.push(e2[1]);
                  delete j.removed_edges[e2[1].index];
                }
                if (j.nodes[e2[1].n1] == null) {
                  j.nodes[e2[1].n1] = e2[1].src;
                  delete j.removed_nodes[e2[1].n1];
                }
                console.warn(s + " " + e2[0].n1 + " --> " + (find_node_scaff(e2[1].n1)) + " " + e2[1].n1 + " --> " + ss + " " + e2[1].n2 + " -- " + e2[0].bits + " + " + e2[1].bits + " bits");
              }
            }
          }
        } else {
          if (s === ss) {
            continue;
          }
          if (!(edge_cache.length > 0)) {
            console.warn("Checking " + s + "...");
            ref7 = j.removed_edges;
            for (u = 0, len1 = ref7.length; u < len1; u++) {
              e = ref7[u];
              if (((e != null ? e.bits : void 0) >= args.thresh) && ((ref8 = e.n1, indexOf.call(c, ref8) >= 0) || (ref9 = e.n2, indexOf.call(c, ref9) >= 0))) {
                edge_cache.push(e);
              }
            }
          }
          for (v = 0, len2 = edge_cache.length; v < len2; v++) {
            e = edge_cache[v];
            if (!((ref10 = e.n1, indexOf.call(cc, ref10) >= 0) || (ref11 = e.n2, indexOf.call(cc, ref11) >= 0))) {
              continue;
            }
            delete j.removed_edges[e.index];
            e.interscaffold = true;
            j.edges.push(e);
            if (ref12 = e.n1, indexOf.call(c, ref12) >= 0) {
              console.warn(s + " " + e.n1 + " --> " + ss + " " + e.n2 + " -- " + e.bits + " bits");
            } else {
              console.warn(s + " " + e.n2 + " --> " + ss + " " + e.n1 + " -- " + e.bits + " bits");
            }
          }
        }
      }
    }
    remove_graph_refs(j);
    delete j.connected_comps;
    if (j.scaffolds != null) {
      delete j.scaffolds;
    }
    if (j.clusters != null) {
      delete j.clusters;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Relink
   */

  relink = function(j, args, callback) {
    var c, e, edge, edge_list, edges_added, err, i1, id, in_nodes_added, j1, k1, len, len1, len2, len3, len4, len5, len6, len7, len8, m, n, name, name1, name2, nid, node_list, nodes_added, out_nodes_added, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, u, v, w, y, z;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Reconnect previously removed connections between contigs");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n name : \"contig_name\" -- Use a single contig by name\n \n Example: " + args.help + " {\"name\":\"NODE_1234\"} -- Restore edges to this contig\n \n names : [\"contig_name1\",\"contig_name2\",...] -- Use multiple contigs by name\n \n Example: " + args.help + " {\"names\":[\"NODE_1234\",\"NODE_5678\"]} -- Restore edges\n to these two contigs (though not necessarily between them...)\n \n ccname : \"contig_name\" -- Use all contigs in the connected component containing the\n named contig\n \n Example: " + args.help + " {\"ccname\":\"NODE_1234\"} -- Restore edges to all contigs\n in the connected component containing this contig\n \n ccnames : [\"contig_name1\",\"contig_name2\",...] -- Restore edges to all contigs\n in the connected components containing these contigs\n \n Example: " + args.help + " {\"ccnames\":[\"NODE_1234\",\"NODE_5678\"]} -- Restore edges\n to all contigs within the connected compontent(s) containing these two contigs\n \n radius : <int> -- Expand the sphere of restored connections to neighbors\n \n Default: " + args.help + " {\"radius\":0} -- Restore edges only to neighboring contigs\n \n Example: " + args.help + " {\"radius\":2} -- Restore edges to all contigs within two\n hops of the selected contigs (including along newly restored paths)\n \n complete : true -- Restore connections among all types of contigs\n \n Example: " + args.help + " {\"complete\":true} -- Restore connections between contigs\n which are both removed from, and part of, currently selected connected components\n \n Default: " + args.help + " {\"complete\":false} -- The 'existing' parameter (below)\n determines which type of connections are restored.\n \n existing : true -- Only restore connections between contigs currently part of selected\n connected components. This parameter has no effect when the 'complete' parmeter\n (above) is true.\n \n Example: " + args.help + " {\"existing\":true} -- Only restore connection between\n currently selected contigs\n \n Default: " + args.help + " {\"existing\":false} -- Only restore connection between\n currently selected and currently unselected contigs; That is, no new connections\n within the contigs of currently selected connected components are restored.\n \n problems : true -- Restore all connections to contigs that are marked with potential\n assembly problems\n \n Example: " + args.help + " {\"problems\":true} -- Reconnect all problem contigs to\n all of their potential neighbors.  Uses radius:1 and existing:true\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.problems == null) {
      args.problems = false;
    }
    if (args.problems) {
      args.radius = 1;
      args.existing = true;
      args.names = (function() {
        var ref, results;
        ref = j.nodes;
        results = [];
        for (nid in ref) {
          n = ref[nid];
          if (n.contig_problems != null) {
            results.push(nid);
          }
        }
        return results;
      })();
    }
    if (args.complete == null) {
      args.complete = false;
    }
    if (args.existing == null) {
      args.existing = false;
    }
    if (args.thresh == null) {
      args.thresh = 0.0;
    }
    if (args.radius == null) {
      args.radius = 0;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    node_list = {};
    if (args.ccname != null) {
      args.ccnames = [args.ccname];
    }
    if (args.ccnames != null) {
      if (args.names == null) {
        args.names = [];
      }
      ref = args.ccnames;
      for (m = 0, len = ref.length; m < len; m++) {
        id = ref[m];
        ref1 = j.connected_comps;
        for (u = 0, len1 = ref1.length; u < len1; u++) {
          c = ref1[u];
          if (c.indexOf(id) !== -1) {
            args.names = args.names.concat(c);
          }
        }
      }
    }
    if (args.name != null) {
      args.names = [args.name];
    }
    if (args.radius && (args.names != null)) {
      ref2 = args.names;
      for (v = 0, len2 = ref2.length; v < len2; v++) {
        name = ref2[v];
        ref3 = find_neighbors(j.nodes[name], args.radius);
        for (w = 0, len3 = ref3.length; w < len3; w++) {
          nid = ref3[w];
          node_list[nid] = j.nodes[nid];
        }
      }
    }
    if (args.names != null) {
      ref4 = args.names;
      for (y = 0, len4 = ref4.length; y < len4; y++) {
        id = ref4[y];
        node_list[id] = j.nodes[id];
      }
    } else {
      node_list = j.nodes;
    }
    in_nodes_added = {};
    out_nodes_added = {};
    nodes_added = {};
    edges_added = [];
    if (!args.existing) {
      for (id in node_list) {
        n = node_list[id];
        ref5 = n.rem_links;
        for (z = 0, len5 = ref5.length; z < len5; z++) {
          e = ref5[z];
          if ((j.removed_nodes[e[1].id] != null) && (edge = edge_director(n, e[1], e[0]) && e[0].score >= args.thresh)) {
            if (id === edge.n1) {
              if (out_nodes_added[name1 = e[1].id] == null) {
                out_nodes_added[name1] = [];
              }
              out_nodes_added[e[1].id].push(e[0]);
            } else {
              if (in_nodes_added[name2 = e[1].id] == null) {
                in_nodes_added[name2] = [];
              }
              in_nodes_added[e[1].id].push(e[0]);
            }
          }
        }
      }
      for (id in in_nodes_added) {
        edge_list = in_nodes_added[id];
        edges_added = edges_added.concat(edge_list);
        nodes_added[id] = j.removed_nodes[id];
      }
      for (id in out_nodes_added) {
        edge_list = out_nodes_added[id];
        edges_added = edges_added.concat(edge_list);
        nodes_added[id] = j.removed_nodes[id];
      }
      ref6 = j.removed_edges;
      for (i1 = 0, len6 = ref6.length; i1 < len6; i1++) {
        e = ref6[i1];
        if (((e != null) && ((nodes_added[e.n1] != null) && (nodes_added[e.n2] != null))) && e.score >= args.thresh) {
          if ((edge = edge_director(e.src, e.tar, e))) {
            edges_added.push(edge);
          }
        }
      }
    }
    if (args.complete || args.existing) {
      for (id in node_list) {
        n = node_list[id];
        if ((!args.ends) || (n.links.length === 1)) {
          ref7 = n.rem_inlinks;
          for (j1 = 0, len7 = ref7.length; j1 < len7; j1++) {
            e = ref7[j1];
            if (e[0].score >= args.thresh) {
              if ((j.nodes[e[1].id] != null) && (edge = edge_director(n, e[1], e[0]))) {
                edges_added.push(edge);
                delete j.removed_edges[edge.index];
              }
            }
          }
        }
      }
    }
    for (id in nodes_added) {
      n = nodes_added[id];
      j.nodes[id] = n;
      delete j.removed_nodes[id];
    }
    for (k1 = 0, len8 = edges_added.length; k1 < len8; k1++) {
      e = edges_added[k1];
      j.edges.push(e);
      delete j.removed_edges[e.index];
    }
    delete j.connected_comps;
    if (j.scaffolds != null) {
      delete j.scaffolds;
    }
    if (j.clusters != null) {
      delete j.clusters;
    }
    remove_graph_refs(j, function(n) {
      return delete n.seen;
    });
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Full Ordering -- This is like Relink above, but it inserts extra dependency edges
   * between added nodes based on mate-pair mapping positions in scaffold nodes
   */

  full_order = function(j, args, callback) {
    var add_dep_edges, all_mers, all_mers_shared, base, base_n, base_p, c, calc_mers, cc_chain_levels, cc_list, chain_levels, chain_minmax, check_list, cnt, contig_mers, cur_lev, dep_edges_added, die, dup, e, e_n, e_p, edge, edge_list, edge_obj, edges_added, err, good, head, i, i1, id, idx, in_idx, in_nodes_added, j1, k1, l, l1, len, len1, len10, len11, len12, len13, len14, len15, len16, len17, len2, len3, len4, len5, len6, len7, len8, len9, m, m1, mers_shared, n, n1, name1, name2, name3, name4, name5, name6, name7, new_in_edges, new_in_idx, new_out_edges, new_out_idx, next, nid, node, node_id, nodes_added, o1, other, out_idx, out_nodes_added, p, p1, pos, pos_rank, prev, q1, r1, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref30, ref31, ref4, ref5, ref6, ref7, ref8, ref9, results, s1, shared_mers, shared_seq_nodes, tail, u, u1, v, v1, w, y, z;
    if (args == null) {
      args = {
        "verbose": false
      };
    }
    if (args.help != null) {
      console.warn(args.help + " -- Reconnect contigs with ambiguous placement within a scaffold using mapped\n pair position information to resolve ambiguities");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n ccname : \"contig_name\" -- Use the connected component containing the named contig\n \n Example: " + args.help + " {\"ccname\":\"NODE_1234\"} -- Insert removed contigs\n within the connected component containing this contig\n \n ccnames : [\"contig_name1\",\"contig_name2\",...] -- Insert removed contigs within the\n connected components containing these contigs\n \n thresh : <float> -- Minimum contig connection bitscore to consider\n \n Example: " + args.help + " {\"thresh\":250.0} -- Default. Only connections scoring\n at least 250.0 bits will count in the calculations\n \n min_pos_diff : <int> -- Minimum mapping position difference (within a neighboring contig)\n considered reliable enough to use for resolving positional ambiguities.\n \n Example: " + args.help + " {\"min_pos_diff\":75} -- Default. Only pairing information\n yielding a relative position difference of 75 nucleotides (between candidate\n contigs and a neighboring existing contig) will be considered significant enough\n to use in determining the relative ordering of the candidate contigs\n \n dup_kmer : <int> -- Length of k-mers to use for detecting variant duplicate contigs\n \n Example: " + args.help + " {\"dup_kmer\":14} -- Default. Use 14-mers to detect\n duplicate variant contigs before inserting them between scaffold backbone contigs.\n Example: " + args.help + " {\"dup_kmer\":0} -- Disable duplicate variant contig checks.\n \n dup_thresh : <float> -- Fraction of kmers from a contig with hits to scaffold backbone.\n \n Example: " + args.help + " {\"dup_thresh\":0.15} -- Default. If more than 15% of kmers\n for a contig hit kmers from the scaffold backbone contigs, then do not insert\n that contig.\n \n external : true -- Controls whether contigs may be inserted outside of an input scaffold.\n \n Default: " + args.help + " {\"external\":false} -- Contigs will not be added outside of\n first and last contigs in the input scaffold; that is, the only inserts performed\n will be between existing connected contigs.\n \n Example: " + args.help + " {\"external\":true} -- Contigs may be added to\n the scaffold before the first, or after the last, contig in an input scaffold.\n \n verbose : true -- output diagnostics on STDERR\n \n Example: " + args.help + " {\"verbose\":true} -- Generate extra output information\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    cc_list = [];
    if (args.thresh == null) {
      args.thresh = 250.0;
    }
    if (args.min_pos_diff == null) {
      args.min_pos_diff = 75;
    }
    if (args.external == null) {
      args.external = false;
    }
    if (args.dup_kmer == null) {
      args.dup_kmer = 14;
    }
    if (args.dup_thresh == null) {
      args.dup_thresh = 0.15;
    }
    if (args.ccname != null) {
      args.ccnames = [args.ccname];
    }
    if (args.ccnames != null) {
      ref = args.ccnames;
      for (m = 0, len = ref.length; m < len; m++) {
        id = ref[m];
        ref1 = j.connected_comps;
        for (i = u = 0, len1 = ref1.length; u < len1; i = ++u) {
          c = ref1[i];
          if (c.indexOf(id) !== -1) {
            cc_list.push(i);
          }
        }
      }
    } else {
      cc_list = (function() {
        results = [];
        for (var v = 0, ref2 = j.connected_comps.length; 0 <= ref2 ? v < ref2 : v > ref2; 0 <= ref2 ? v++ : v--){ results.push(v); }
        return results;
      }).apply(this);
    }
    nodes_added = {};
    edges_added = [];
    cc_chain_levels = [];
    for (w = 0, len2 = cc_list.length; w < len2; w++) {
      idx = cc_list[w];
      in_nodes_added = {};
      out_nodes_added = {};
      shared_seq_nodes = {};
      in_idx = {};
      out_idx = {};
      c = j.connected_comps[idx];
      try {
        ref3 = find_ends(j, c, true), (ref4 = ref3[0], head = ref4[0]), (ref5 = ref3[1], tail = ref5[0]);
      } catch (error1) {
        err = error1;
        remove_graph_refs(j);
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      chain_levels = [];
      n = head;
      i = 1;
      while (n) {
        chain_levels[i - 1] = n;
        n.chain_idx = i;
        n.ccnum = idx;
        n.cclen = c.length;
        i++;
        n = (ref6 = n.outlinks[0]) != null ? ref6[1] : void 0;
      }
      cc_chain_levels.push(chain_levels);
      calc_mers = function(k, seq, mers) {
        var ref7, y;
        if (mers == null) {
          mers = {};
        }
        for (c = y = 0, ref7 = seq.length - k; 0 <= ref7 ? y <= ref7 : y >= ref7; c = 0 <= ref7 ? ++y : --y) {
          mers[seq.slice(c, c + k)] = true;
        }
        return mers;
      };
      shared_mers = function(ref_mers, query_mers) {
        var len3, q, q_mers, total, y;
        q_mers = Object.keys(query_mers);
        total = 0;
        for (y = 0, len3 = q_mers.length; y < len3; y++) {
          q = q_mers[y];
          if (ref_mers[q] != null) {
            total++;
          }
        }
        return total / q_mers.length;
      };
      mers_shared = 0.0;
      all_mers_shared = 0.0;
      if (args.dup_kmer) {
        all_mers = {};
        for (l = y = 0, len3 = chain_levels.length; y < len3; l = ++y) {
          n = chain_levels[l];
          if (((ref7 = n.seq) != null ? ref7.length : void 0) >= args.dup_kmer) {
            all_mers = calc_mers(args.dup_kmer, n.seq, all_mers);
          }
        }
        if (!Object.keys(all_mers).length) {
          if (args.verbose) {
            console.warn("INSERT parameter dup_kmer = " + args.dup_kmer + " but graph has no sequence. Disabling INSERT kmer checking.");
          }
          args.dup_kmer = 0;
        }
      }
      for (l = z = 0, len4 = chain_levels.length; z < len4; l = ++z) {
        n = chain_levels[l];
        ref8 = n.rem_links;
        for (i1 = 0, len5 = ref8.length; i1 < len5; i1++) {
          e = ref8[i1];
          if (!((j.removed_nodes[e[1].id] != null) && (edge = edge_director(n, e[1], e[0])))) {
            continue;
          }
          other = n.id === edge.n1 ? edge.n2 : edge.n1;
          if (args.dup_kmer && ((ref9 = e[1].seq) != null ? ref9.length : void 0) >= args.dup_kmer) {
            contig_mers = calc_mers(args.dup_kmer, e[1].seq);
            all_mers_shared = shared_mers(all_mers, contig_mers);
          }
          if (all_mers_shared > args.dup_thresh) {
            if (shared_seq_nodes[other] == null) {
              shared_seq_nodes[other] = [];
            }
            shared_seq_nodes[other].push(n.id);
            if (args.verbose) {
              console.warn("Shared sequence variant node " + other + " rejected from " + n.id + " " + args.dup_kmer + "_mers shared: " + all_mers_shared);
            }
          } else {
            if (n.id === edge.n1) {
              if (out_nodes_added[name1 = e[1].id] == null) {
                out_nodes_added[name1] = [];
              }
              out_nodes_added[e[1].id].push(e[0]);
              if (out_idx[name2 = e[1].id] == null) {
                out_idx[name2] = [];
              }
              out_idx[e[1].id].push(n.chain_idx);
            } else {
              if (in_nodes_added[name3 = e[1].id] == null) {
                in_nodes_added[name3] = [];
              }
              in_nodes_added[e[1].id].push(e[0]);
              if (in_idx[name4 = e[1].id] == null) {
                in_idx[name4] = [];
              }
              in_idx[e[1].id].push(n.chain_idx);
            }
          }
        }
      }
      for (id in shared_seq_nodes) {
        delete in_nodes_added[id];
        delete in_idx[id];
        delete out_nodes_added[id];
        delete out_idx[id];
      }
      for (id in in_nodes_added) {
        edge_list = in_nodes_added[id];
        if (!(out_nodes_added[id] == null)) {
          continue;
        }
        delete in_nodes_added[id];
        delete in_idx[id];
      }
      for (id in out_nodes_added) {
        edge_list = out_nodes_added[id];
        if (!(in_nodes_added[id] == null)) {
          continue;
        }
        delete out_nodes_added[id];
        delete out_idx[id];
      }
      chain_minmax = {};
      for (id in in_idx) {
        check_list = {};
        ref10 = j.removed_nodes[id].rem_links;
        for (j1 = 0, len6 = ref10.length; j1 < len6; j1++) {
          ref11 = ref10[j1], e = ref11[0], n = ref11[1];
          if (!(in_idx[n.id] != null)) {
            continue;
          }
          if (check_list[name5 = n.id] == null) {
            check_list[name5] = 0;
          }
          check_list[n.id]++;
        }
        die = false;
        for (nid in check_list) {
          cnt = check_list[nid];
          if (!(cnt > 1 && j.removed_nodes[id].seq_len < j.removed_nodes[nid].seq_len)) {
            continue;
          }
          die = true;
          if (args.verbose) {
            console.warn("Circular variant node " + id + " rejected");
          }
          break;
        }
        if (die) {
          break;
        }
        dup = false;
        if (nodes_added[id] != null) {
          if ((base = j.removed_nodes[id]).dup == null) {
            base.dup = 0;
          }
          j.removed_nodes[id].dup++;
          node_id = id + ("_Dup_" + j.removed_nodes[id].dup);
          node = {};
          for (p in j.removed_nodes[id]) {
            node[p] = j.removed_nodes[id][p];
          }
          node.name = node_id;
          node.id = node_id;
          dup = true;
        } else {
          node_id = id;
          node = j.removed_nodes[id];
        }
        chain_minmax = {
          ins: {
            min: Math.min.apply(null, out_idx[id]),
            max: Math.max.apply(null, out_idx[id])
          },
          outs: {
            min: Math.min.apply(null, in_idx[id]),
            max: Math.max.apply(null, in_idx[id])
          }
        };
        if ((chain_minmax.ins.max < chain_minmax.outs.min) && (chain_minmax.outs.max - chain_minmax.ins.min < 7)) {
          edges_added = edges_added.concat(out_nodes_added[id]).concat(in_nodes_added[id]);
          nodes_added[node_id] = node;
          node.slot = [chain_minmax.ins.min, chain_minmax.outs.max];
          node.ccnum = idx;
        } else if (args.external && (chain_minmax.ins.min > chain_minmax.outs.max) && (chain_minmax.outs.max - chain_minmax.outs.min < 4) && (chain_minmax.ins.max - chain_minmax.ins.min < 4) && (chain_minmax.ins.min - chain_minmax.outs.max > j.connected_comps[idx].length - 7)) {
          edges_added = edges_added.concat(out_nodes_added[id]);
          nodes_added[node_id] = node;
          node.slot = [chain_minmax.ins.min, Number.MAX_VALUE];
          node.ccnum = idx;
        } else if ((((chain_minmax.outs.min < (ref13 = chain_minmax.ins.min) && ref13 <= (ref12 = chain_minmax.ins.max)) && ref12 < chain_minmax.outs.max)) && (chain_minmax.ins.max - chain_minmax.ins.min < 4) && (chain_minmax.outs.max - chain_minmax.outs.min > j.connected_comps[idx].length - 7)) {
          new_out_edges = (function() {
            var k1, len7, ref14, results1;
            ref14 = in_nodes_added[id];
            results1 = [];
            for (k1 = 0, len7 = ref14.length; k1 < len7; k1++) {
              e = ref14[k1];
              if (e.tar.chain_idx > chain_minmax.ins.max) {
                results1.push(e);
              }
            }
            return results1;
          })();
          new_out_idx = (function() {
            var k1, len7, results1;
            results1 = [];
            for (k1 = 0, len7 = new_out_edges.length; k1 < len7; k1++) {
              e = new_out_edges[k1];
              results1.push(e.tar.chain_idx);
            }
            return results1;
          })();
          edges_added = edges_added.concat(out_nodes_added[id]).concat(new_out_edges);
          nodes_added[node_id] = node;
          node.slot = [chain_minmax.ins.min, Math.max.apply(null, new_out_idx)];
          node.ccnum = idx;
        } else if ((((chain_minmax.ins.min < (ref15 = chain_minmax.outs.min) && ref15 <= (ref14 = chain_minmax.outs.max)) && ref14 < chain_minmax.ins.max)) && (chain_minmax.outs.max - chain_minmax.outs.min < 4) && (chain_minmax.ins.max - chain_minmax.ins.min > j.connected_comps[idx].length - 7)) {
          new_in_edges = (function() {
            var k1, len7, ref16, results1;
            ref16 = out_nodes_added[id];
            results1 = [];
            for (k1 = 0, len7 = ref16.length; k1 < len7; k1++) {
              e = ref16[k1];
              if (e.src.chain_idx < chain_minmax.outs.min) {
                results1.push(e);
              }
            }
            return results1;
          })();
          new_in_idx = (function() {
            var k1, len7, results1;
            results1 = [];
            for (k1 = 0, len7 = new_in_edges.length; k1 < len7; k1++) {
              e = new_in_edges[k1];
              results1.push(e.src.chain_idx);
            }
            return results1;
          })();
          edges_added = edges_added.concat(in_nodes_added[id]).concat(new_in_edges);
          nodes_added[node_id] = node;
          node.slot = [Math.min.apply(null, new_in_idx), chain_minmax.outs.max];
          node.ccnum = idx;
        } else {
          if (args.verbose) {
            console.warn("Node rejected: " + node_id);
          }
        }
        if ((nodes_added[node_id] != null) && dup) {
          ref16 = out_nodes_added[id];
          for (k1 = 0, len7 = ref16.length; k1 < len7; k1++) {
            e = ref16[k1];
            e.n2 = node_id;
          }
          ref17 = in_nodes_added[id];
          for (l1 = 0, len8 = ref17.length; l1 < len8; l1++) {
            e = ref17[l1];
            e.n1 = node_id;
          }
        }
      }
    }
    ref18 = j.removed_edges;
    for (m1 = 0, len9 = ref18.length; m1 < len9; m1++) {
      e = ref18[m1];
      if ((e != null) && ((nodes_added[e.n1] != null) && (nodes_added[e.n2] != null))) {
        if ((edge = edge_director(e.src, e.tar, e)) && (edge.src.slot[0] <= edge.tar.slot[0]) && (edge.src.slot[1] <= edge.tar.slot[1]) && ((edge.tar.slot[0] - edge.src.slot[1]) < 7) && (edge.src.ccnum === edge.tar.ccnum)) {
          edges_added.push(edge);
        }
      }
    }
    for (id in nodes_added) {
      n = nodes_added[id];
      j.nodes[id] = n;
      delete j.removed_nodes[id];
    }
    for (n1 = 0, len10 = edges_added.length; n1 < len10; n1++) {
      e = edges_added[n1];
      j.edges.push(e);
      delete j.removed_edges[e.index];
    }
    if (args.no_mp_pos_links == null) {
      remove_graph_refs(j);
      try {
        build_graph_refs(j, (function(n) {
          n.out_nodes = {};
          return n.in_nodes = {};
        }), (function(e) {
          e.src.out_nodes[e.n2] = e;
          return e.tar.in_nodes[e.n1] = e;
        }));
      } catch (error1) {
        err = error1;
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      dep_edges_added = [];
      add_dep_edges = function(rank_list) {
        var len11, new_head, new_tail, o1, pos, prev_pos, ref19, results1;
        rank_list.sort(function(a, b) {
          return a[0] - b[0];
        });
        new_tail = null;
        results1 = [];
        for (o1 = 0, len11 = rank_list.length; o1 < len11; o1++) {
          ref19 = rank_list[o1], pos = ref19[0], new_head = ref19[1];
          if (new_tail && (new_tail.out_nodes[new_head.id] == null) && (new_tail.in_nodes[new_head.id] == null) && pos - prev_pos > args.min_pos_diff) {
            dep_edges_added.push({
              n1: new_tail.id,
              n2: new_head.id,
              dir: "pos",
              pos_diff: pos - prev_pos
            });
          }
          new_tail = new_head;
          results1.push(prev_pos = pos);
        }
        return results1;
      };
      for (o1 = 0, len11 = cc_list.length; o1 < len11; o1++) {
        idx = cc_list[o1];
        chain_levels = cc_chain_levels[idx];
        for (l = p1 = 0, len12 = chain_levels.length; p1 < len12; l = ++p1) {
          n = chain_levels[l];
          base_p = 0;
          base_n = 0;
          cur_lev = {};
          pos_rank = [];
          prev = chain_levels != null ? (ref19 = chain_levels[l - 1]) != null ? ref19.id : void 0 : void 0;
          next = chain_levels != null ? (ref20 = chain_levels[l + 1]) != null ? ref20.id : void 0 : void 0;
          if (prev) {
            base_p = n.in_nodes[prev].p1;
            ref21 = j.nodes[prev].outlinks;
            for (q1 = 0, len13 = ref21.length; q1 < len13; q1++) {
              ref22 = ref21[q1], edge = ref22[0], node = ref22[1];
              cur_lev[edge.n2] = [edge];
            }
          }
          if (next) {
            base_n = n.out_nodes[next].p2;
            ref23 = j.nodes[next].inlinks;
            for (r1 = 0, len14 = ref23.length; r1 < len14; r1++) {
              ref24 = ref23[r1], edge = ref24[0], node = ref24[1];
              if (cur_lev[name6 = edge.n1] == null) {
                cur_lev[name6] = [];
              }
              cur_lev[edge.n1][1] = edge;
            }
          }
          for (id in cur_lev) {
            ref25 = cur_lev[id], e_p = ref25[0], e_n = ref25[1];
            if (e_p && e_n && (e_p.bits + e_n.bits > args.thresh)) {
              pos = ((e_p.bits / (e_p.bits + e_n.bits)) * (e_p.p1 - base_p)) + ((e_n.bits / (e_p.bits + e_n.bits)) * (e_n.p2 - base_n));
              pos_rank.push([pos, e_p.tar]);
            } else if (e_p && (e_p.bits > args.thresh) && !(((ref26 = j.nodes[next]) != null ? (ref27 = ref26.out_nodes) != null ? ref27[e_p.tar.id] : void 0 : void 0) != null)) {
              pos = e_p.p1 - base_p;
              pos_rank.push([pos, e_p.tar]);
            } else if (e_n && (e_n.bits > args.thresh) && !(((ref28 = j.nodes[prev]) != null ? (ref29 = ref28.in_nodes) != null ? ref29[e_n.src.id] : void 0 : void 0) != null)) {
              pos = e_n.p2 - base_n;
              pos_rank.push([pos, e_n.src]);
            }
          }
          add_dep_edges(pos_rank);
        }
      }
      edge_obj = {};
      for (s1 = 0, len15 = dep_edges_added.length; s1 < len15; s1++) {
        e = dep_edges_added[s1];
        if (edge_obj[name7 = e.n1 + "_" + e.n2] == null) {
          edge_obj[name7] = 0;
        }
        edge_obj[e.n1 + "_" + e.n2]++;
      }
      for (u1 = 0, len16 = dep_edges_added.length; u1 < len16; u1++) {
        e = dep_edges_added[u1];
        if (!(edge_obj[e.n2 + "_" + e.n1] || --edge_obj[e.n1 + "_" + e.n2])) {
          good = true;
          ref30 = j.nodes[e.n2].outlinks;
          for (v1 = 0, len17 = ref30.length; v1 < len17; v1++) {
            ref31 = ref30[v1], edge = ref31[0], node = ref31[1];
            if (!node.out_nodes[e.n1]) {
              continue;
            }
            good = false;
            break;
          }
          if (good) {
            j.edges.push(e);
          }
        }
      }
    }
    remove_graph_refs(j, function(n) {
      delete n.in_nodes;
      delete n.out_nodes;
      delete n.ccnum;
      delete n.cclen;
      delete n.chain_idx;
      return delete n.slot;
    });
    delete j.connected_comps;
    if (j.scaffolds != null) {
      delete j.scaffolds;
    }
    if (j.clusters != null) {
      delete j.clusters;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Layout scaffolds
   */

  scaffold = function(j, args, callback) {
    var all_scaffs, all_tsort, c, cci, ccomp_ends, e, edge, ei, end_id, err, i, i1, id, in_keys, in_node, in_scaffs, j1, k1, len, len1, len2, len3, len4, len5, len6, len7, len8, len_to, longest_chain, m, max_id, max_len, n, n2, node, out_node, prev, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, remove_cands, scaf_name, sink_nodes, source_nodes, tsort, u, v, w, y, z;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Lay out a fully linear scaffold from contigs in unambiguously ordered\n connected components");
      if (args.detailed_help != null) {
        console.warn("\n Parameters: NONE.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.scaffolds != null) {
      delete j.scaffolds;
    }
    if (j.clusters != null) {
      delete j.clusters;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      ccomp_ends = find_all_ends(j);
      build_graph_refs(j, (function(n) {
        return n.in_edges = {};
      }), (function(e) {
        return e.tar.in_edges[e.src.id] = e;
      }));
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    all_tsort = [];
    all_scaffs = [];
    in_scaffs = {};
    for (cci = m = 0, len = ccomp_ends.length; m < len; cci = ++m) {
      ref = ccomp_ends[cci], source_nodes = ref[0], sink_nodes = ref[1];
      tsort = [];
      for (u = 0, len1 = source_nodes.length; u < len1; u++) {
        n = source_nodes[u];
        n.in_edges = {};
      }
      while (n = source_nodes.pop()) {
        tsort.push(n.id);
        ref1 = n.outlinks;
        for (v = 0, len2 = ref1.length; v < len2; v++) {
          e = ref1[v];
          delete e[1].in_edges[n.id];
          if (Object.keys(e[1].in_edges).length === 0) {
            source_nodes.push(e[1]);
          }
        }
        if (!args.no_rescue && (source_nodes.length === 0) && (tsort.length !== j.connected_comps[cci].length)) {
          remove_cands = (function() {
            var len3, ref2, results, w;
            ref2 = j.connected_comps[cci];
            results = [];
            for (w = 0, len3 = ref2.length; w < len3; w++) {
              id = ref2[w];
              if ((tsort.indexOf(id) === -1) && ((in_keys = Object.keys(j.nodes[id].in_edges)).length === 1) && (j.nodes[id].in_edges[in_keys[0]].pos_diff != null)) {
                results.push([j.nodes[id], j.nodes[in_keys[0]]]);
              }
            }
            return results;
          })();
          if (remove_cands.length) {
            remove_cands.sort(function(a, b) {
              return a[0].in_edges[a[1].id].pos_diff - b[0].in_edges[b[1].id].pos_diff;
            });
            ref2 = remove_cands[0], in_node = ref2[0], out_node = ref2[1];
            console.warn("Rescuing node " + remove_cands[0][0].id + ": position dependent edge from " + remove_cands[0][1].id);
            ref3 = out_node.outlinks;
            for (ei = w = 0, len3 = ref3.length; w < len3; ei = ++w) {
              edge = ref3[ei];
              if (!(edge[0] === in_node.in_edges[out_node.id])) {
                continue;
              }
              out_node.outlinks.splice(ei, 1);
              break;
            }
            delete in_node.in_edges[out_node.id];
            source_nodes.push(in_node);
          }
        }
      }
      all_tsort.push(tsort);
      len_to = {};
      if (!tsort.length) {
        if (typeof callback === "function") {
          callback(new Error("SCAFF: No nodes in topological sort list. Circular scaffold?"), null);
        }
        return;
      }
      max_id = tsort[0];
      max_len = j.nodes[max_id].seq_len;
      for (y = 0, len4 = tsort.length; y < len4; y++) {
        id = tsort[y];
        n = j.nodes[id];
        if (len_to[id] == null) {
          len_to[id] = {
            len: n.seq_len,
            edge: null
          };
        }
        ref4 = n.outlinks;
        for (z = 0, len5 = ref4.length; z < len5; z++) {
          ref5 = ref4[z], e = ref5[0], n2 = ref5[1];
          if (!((len_to[n2.id] == null) || (len_to[n2.id].len < len_to[id].len + n2.seq_len))) {
            continue;
          }
          len_to[n2.id] = {
            len: len_to[id].len + n2.seq_len,
            edge: e
          };
          if (len_to[n2.id].len > max_len) {
            max_id = n2.id;
            max_len = len_to[n2.id].len;
          }
        }
      }
      longest_chain = [j.nodes[max_id]];
      if ((ref6 = len_to[max_id].edge) != null) {
        ref6.keep = true;
      }
      prev = len_to[max_id];
      while (prev.edge != null) {
        longest_chain.unshift(prev.edge.src);
        prev.edge.keep = true;
        prev = len_to[prev.edge.src.id];
      }
      for (i = i1 = 0, len6 = longest_chain.length; i1 < len6; i = ++i1) {
        n = longest_chain[i];
        all_scaffs.push(n.id);
        in_scaffs[n.id] = i;
      }
      if (sink_nodes.indexOf(longest_chain[longest_chain.length - 1]) === -1) {
        end_id = longest_chain[longest_chain.length - 1].id;
        console.warn("Scaffold Warning: CCOMP " + cci + " was not completely traversed. " + end_id + " " + ((100.0 * (tsort.length / j.connected_comps[cci].length)).toFixed(1)) + "% " + ((100.0 * (longest_chain.length / j.connected_comps[cci].length)).toFixed(1)) + "% ");
      }
    }
    ref7 = j.edges;
    for (j1 = 0, len7 = ref7.length; j1 < len7; j1++) {
      e = ref7[j1];
      if (!((e != null ? e.keep : void 0) == null)) {
        continue;
      }
      j.removed_edges.push(e);
      delete j.edges[e.index];
    }
    ref8 = j.nodes;
    for (id in ref8) {
      n = ref8[id];
      if (!(in_scaffs[id] == null)) {
        continue;
      }
      j.removed_nodes[id] = n;
      delete j.nodes[id];
    }
    remove_graph_refs(j, function(n) {
      delete n.in_edges;
      return delete n.saved_outlinks;
    }, function(e) {
      return delete e.keep;
    });
    calc_ccomps(j);
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    j.scaffolds = {};
    ref9 = j.connected_comps;
    for (i = k1 = 0, len8 = ref9.length; k1 < len8; i = ++k1) {
      c = ref9[i];
      scaf_name = "Scaffold_" + i;
      j.scaffolds[scaf_name] = {
        "ccnum": i,
        "nodes": []
      };
      try {
        node = find_ends(j, c, true)[0][0];
      } catch (error1) {
        err = error1;
        remove_graph_refs(j);
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      while (node) {
        if (node.seq != null) {
          j.scaffolds[scaf_name].nodes.push(node.id);
        }
        node = (ref10 = node.outlinks[0]) != null ? ref10[1] : void 0;
      }
    }
    if (j.clusters != null) {
      delete j.clusters;
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Make explicit edits to the current assembly graph
   */

  perform_edits = function(j, args, callback) {
    var e, err, i1, len, len1, len2, len3, len4, len5, len6, m, n2_list, nid, nid1, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, type, u, v, w, y, z;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Make manual explicit edits to the selected graph structure");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n rem_nodes : [\"contig1\",\"contig2\",...] -- Remove the specified contig nodes by name\n \n Example: " + args.help + " {\"rem_nodes\":[\"NODE_1234\",\"NODE_5678\"]} -- Remove\n these two contigs from the graph\n \n add_nodes : [\"contig1\",\"contig2\",...] -- Add back the specified contig nodes by name\n \n Example: " + args.help + " {\"add_nodes\":[\"NODE_1234\",\"NODE_5678\"]} -- Move\n these two contigs from the removed pool to the selected graph\n \n rem_edges : [\"contig1\",[\"contig2\",...]] -- Remove the specified connections between\n contig1 and any number of others.\n \n Example: " + args.help + " {\"rem_edges\":[\"NODE_1234\",[\"NODE_5678\",\"NODE_9\"]]}\n -- Remove two connection edges from the graph, both connected to NODE_1234\n \n add_edges : [\"contig1\",[\"contig2\",...]] -- Add back the specified connections between\n contig1 and any number of others.\n \n Example: " + args.help + " {\"add_edges\":[\"NODE_1234\",[\"NODE_5678\",\"NODE_9\"]]}\n -- Add two connection edges from the graph, both connected to NODE_1234\n \n NOTE: for rem_edges and add_edges above, if only a single edge is involved, then\n the parameter syntax may optionally be flattened. For example:\n {\"add_edges\":[\"NODE_1234\",[\"NODE_9\"]]} is equivalent to\n {\"add_edges\":[\"NODE_1234\",\"NODE_9\"]}\n \n If more than one node-independent sets of edges are to be added or removed (that\n is, those not sharing any contig(s) in common), then multiple calls to " + args.help + "\n are required to accomplish this task.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.rem_nodes == null) {
      args.rem_nodes = [];
    }
    if (args.rem_edges == null) {
      args.rem_edges = [];
    }
    if (args.add_nodes == null) {
      args.add_nodes = [];
    }
    if (args.add_edges == null) {
      args.add_edges = [];
    }
    type = (function() {
      var classToType, len, m, name, ref;
      classToType = {};
      ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
      for (m = 0, len = ref.length; m < len; m++) {
        name = ref[m];
        classToType["[object " + name + "]"] = name.toLowerCase();
      }
      return function(obj) {
        var strType;
        strType = Object.prototype.toString.call(obj);
        return classToType[strType] || "object";
      };
    })();
    ref = args.add_nodes;
    for (m = 0, len = ref.length; m < len; m++) {
      nid = ref[m];
      if (!(j.removed_nodes[nid] != null)) {
        continue;
      }
      console.warn("EDIT: Adding node " + nid);
      j.nodes[nid] = j.removed_nodes[nid];
      delete j.removed_nodes[nid];
    }
    ref1 = args.add_edges;
    for (u = 0, len1 = ref1.length; u < len1; u++) {
      ref2 = ref1[u], nid1 = ref2[0], n2_list = ref2[1];
      if (!(j.nodes[nid1] != null)) {
        continue;
      }
      if (type(n2_list) === "string") {
        n2_list = [n2_list];
      }
      ref3 = j.nodes[nid1].rem_links;
      for (v = 0, len2 = ref3.length; v < len2; v++) {
        e = ref3[v];
        if (!((n2_list.indexOf(e[1].id) !== -1) && (j.removed_edges[e[0].index] != null))) {
          continue;
        }
        console.warn("EDIT: Adding edge " + e[0].n1 + " --> " + e[0].n2 + " Index: " + e[0].index + " " + j.removed_edges[e[0].index].n1 + " --> " + j.removed_edges[e[0].index].n2);
        delete j.removed_edges[e[0].index];
        e[0].index = j.edges.push(e[0]) - 1;
      }
    }
    ref4 = args.rem_nodes;
    for (w = 0, len3 = ref4.length; w < len3; w++) {
      nid = ref4[w];
      if (!(j.nodes[nid] != null)) {
        continue;
      }
      console.warn("EDIT: Deleting node " + nid);
      ref5 = j.nodes[nid].links;
      for (y = 0, len4 = ref5.length; y < len4; y++) {
        e = ref5[y];
        if (!(j.edges[e[0].index] != null)) {
          continue;
        }
        console.warn("EDIT: Removing edge " + e[0].n1 + " --> " + e[0].n2 + " Index: " + e[0].index + " " + j.edges[e[0].index].n1 + " --> " + j.edges[e[0].index].n2);
        delete j.edges[e[0].index];
        e[0].index = j.removed_edges.push(e[0]) - 1;
      }
      j.removed_nodes[nid] = j.nodes[nid];
      delete j.nodes[nid];
    }
    ref6 = args.rem_edges;
    for (z = 0, len5 = ref6.length; z < len5; z++) {
      ref7 = ref6[z], nid1 = ref7[0], n2_list = ref7[1];
      if (!(j.nodes[nid1] != null)) {
        continue;
      }
      if (type(n2_list) === "string") {
        n2_list = [n2_list];
      }
      ref8 = j.nodes[nid1].links;
      for (i1 = 0, len6 = ref8.length; i1 < len6; i1++) {
        e = ref8[i1];
        if (!((n2_list.indexOf(e[1].id) !== -1) && (j.edges[e[0].index] != null))) {
          continue;
        }
        console.warn("EDIT: Removing edge " + e[0].n1 + " --> " + e[0].n2 + " Index: " + e[0].index + " " + j.edges[e[0].index].n1 + " --> " + j.edges[e[0].index].n2);
        delete j.edges[e[0].index];
        e[0].index = j.removed_edges.push(e[0]) - 1;
      }
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * create new nodes from parts of the given nodes
   */

  cut_node = function(j, args, callback) {
    var e, err, k, len, len1, len2, len3, m, new_node, node, p, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, u, v, w;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Create a new node from an existing node using the given coordinates");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n name : \"contig_name\" -- Name of the contig node to be copied\n \n Example: " + args.help + " {\"name\":\"NODE_1234\"} -- Use sequence from NODE_1234\n \n new_name : \"new_contig_name\" -- Name for the newly created contig node\n \n Example: " + args.help + " {\"new_name\":\"NODE_1234a\"} -- New node will be named\n NODE_1234a\n \n include : [\"contig_name1\", ...] -- Move mate-pair edges from the listed contigs.\n \n Example: " + args.help + " {\"name\":\"NODE_1234\",\"include\":[\"NODE_567\",\"NODE_234\"]}\n -- Edges between NODE_1234 and the included contigs will be moved to the new cut\n and copied version of NODE_1234.\n \n auto_include : true -- Automatically move mate-pair edges falling within the cut sequence.\n \n Example: " + args.help + " {\"name\":\"NODE_1234\",\"auto_include\":true}\n -- All selected edges between NODE_1234 and any other contigs will be moved to the\n new cut and copied version of NODE_1234. Note that currently removed edges will\n not be moved. To accomplish this, the node needs to be RELINKed first. \n begin : <int> -- Beginning sequence coordinate for the new node within the original\n end : <int> -- Ending sequence coordinate for the new node within the original\n \n NOTE: To facilitate trimming sequences to a fixed maximum length, it is\n allowable for negative 'start' values and positive 'end' values to be longer than\n a sequence. In such cases, the values are set to the start and end of the\n sequence, respectively. Positive start and negative end positions must fall\n within the sequence, because otherwise the start position will be after the end\n position.\n \n Example: " + args.help + " {\"begin\":123,\"end\":456} -- The new node will include\n sequence from positions 123 to 456\n \n Example: " + args.help + " {\"end\":456} -- The new node will include sequence from\n position 0 (implied) to 456. end may also be omitted, implying the last position\n \n Example: " + args.help + " {\"begin\":-1000} -- New node contains at most the last\n 1000 bases of any sequence. Sequences under 1000 bases are copied unmodified.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    node = j.nodes[args.name];
    new_node = {};
    if (!node) {
      if (typeof callback === "function") {
        callback(new Error('CUTND requires a valid node "name" argument.'), null);
      }
      return;
    }
    if ((args.start != null) && (args.begin == null)) {
      console.warn("CUTND: Warning: 'start' parameter is deprecated. Use 'begin' instead.");
      args.begin = args.start;
    }
    if (args.begin == null) {
      args.begin = 0;
    }
    if (args.end == null) {
      args.end = node.seq_len - 1;
    }
    if (args.include == null) {
      args.include = [];
    }
    if (args.begin < 0) {
      args.begin = node.seq_len + args.begin;
    }
    if (args.end < 0) {
      args.end = node.seq_len + args.end;
    }
    if (args.begin < 0) {
      args.begin = 0;
    }
    if (args.end >= node.seq_len) {
      args.end = node.seq_len - 1;
    }
    if (!(args.begin < args.end)) {
      if (typeof callback === "function") {
        callback(new Error('CUTND requires valid "begin" and "end" arguments.'), null);
      }
      return;
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (error1) {
      err = error1;
      console.warn("build_graph_refs error in CUTND");
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    k = 1;
    if (args.new_name == null) {
      args.new_name = ((function() {
        while (j.nodes[node.name + "_Cut_" + k] != null) {
          k++;
        }
        return node.name + "_Cut_" + k;
      })());
    }
    j.nodes[args.new_name] = new_node;
    console.warn("CUTND: Adding " + args.new_name + " from " + args.begin + " - " + args.end + " of " + node.name);
    for (p in node) {
      new_node[p] = node[p];
    }
    new_node.name = args.new_name;
    new_node.id = args.new_name;
    new_node.seq_len = args.end - args.begin + 1;
    delete new_node.contig_problems;
    if (new_node.seq != null) {
      new_node.seq = new_node.seq.substring(args.begin, args.end);
    }
    if (new_node.per_nt != null) {
      if (new_node.per_nt.cov != null) {
        new_node.per_nt.cov = new_node.per_nt.cov.slice(args.begin, args.end);
      }
      if (new_node.per_nt.phys_cov != null) {
        new_node.per_nt.phys_cov = new_node.per_nt.phys_cov.slice(args.begin, args.end);
      }
      if (new_node.per_nt.mp_ins != null) {
        new_node.per_nt.mp_ins = new_node.per_nt.mp_ins.slice(args.begin, args.end);
      }
      if (new_node.per_nt.gc_mean != null) {
        new_node.per_nt.gc_mean = new_node.per_nt.gc_mean.slice(args.begin, args.end);
      }
    }
    if (((ref = new_node.merge_stats) != null ? (ref1 = ref.per_nt) != null ? ref1.cov : void 0 : void 0) != null) {
      new_node.merge_stats.per_nt.cov = new_node.merge_stats.per_nt.cov.slice(args.begin, args.end);
    }
    if (args.auto_include) {
      ref2 = new_node.inlinks;
      for (m = 0, len = ref2.length; m < len; m++) {
        e = ref2[m];
        if ((args.begin <= (ref3 = e[0].p2) && ref3 <= args.end)) {
          args.include.push(e[1].id);
        }
      }
      ref4 = new_node.outlinks;
      for (u = 0, len1 = ref4.length; u < len1; u++) {
        e = ref4[u];
        if ((args.begin <= (ref5 = e[0].p1) && ref5 <= args.end)) {
          args.include.push(e[1].id);
        }
      }
    }
    ref6 = new_node.inlinks;
    for (v = 0, len2 = ref6.length; v < len2; v++) {
      e = ref6[v];
      if (!(((ref7 = args.include) != null ? ref7.indexOf(e[1].id) : void 0) !== -1)) {
        continue;
      }
      console.warn("CUTND: Moving edge " + e[0].n1 + " --> " + e[0].n2 + " to " + args.new_name);
      e[0].n2 = args.new_name;
      if (e[0].p2 < args.begin) {
        e[0].p2 = 0;
      } else if (e[0].p2 > args.end) {
        e[0].p2 = new_node.seq_len - 1;
      } else {
        e[0].p2 = e[0].p2 - args.begin;
      }
    }
    ref8 = new_node.outlinks;
    for (w = 0, len3 = ref8.length; w < len3; w++) {
      e = ref8[w];
      if (!(((ref9 = args.include) != null ? ref9.indexOf(e[1].id) : void 0) !== -1)) {
        continue;
      }
      console.warn("CUTND: Moving edge " + e[0].n1 + " --> " + e[0].n2 + " to " + args.new_name);
      e[0].n1 = args.new_name;
      if (e[0].p1 < args.begin) {
        e[0].p1 = 0;
      } else if (e[0].p1 > args.end) {
        e[0].p1 = new_node.seq_len - 1;
      } else {
        e[0].p1 = e[0].p1 - args.begin;
      }
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * Report on problem contigs
   */

  node_problems = function(j, args, callback) {
    var count, len, m, magnitude, min, minmax, name, name1, node, node_cnt, o, pos, prob_types, problem, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, sign, total, type, u, v, x;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Generate a report of contigs with likely internal assembly issues");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.txt[.gz]\" -- name of txt format file to write statistics to\n \n Example: " + args.help + " {\"file\":\"problems.txt\"} -- Write report to the file\n problems.txt\n \n Example: " + args.help + " {\"file\":\"-\"} -- Default. Write report to STDOUT\n \n detail : true -- Provide extra per contig detail\n \n Example: " + args.help + " {\"detail\":true}\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file, args.tag);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.file !== o.fn) {
      args.output = o.fn;
    }
    if (args.detail == null) {
      args.detail = false;
    }
    node_cnt = 0;
    total = 0;
    prob_types = {};
    ref = j.nodes;
    for (name in ref) {
      node = ref[name];
      if (!(node.contig_problems != null)) {
        continue;
      }
      if (args.detail) {
        o.write(name + "\t" + node.contig_problems.length + "\n");
      }
      node_cnt++;
      ref1 = node.contig_problems;
      for (m = 0, len = ref1.length; m < len; m++) {
        problem = ref1[m];
        total++;
        if (prob_types[name1 = problem.type] == null) {
          prob_types[name1] = 0;
        }
        prob_types[problem.type]++;
        if (args.detail) {
          if (problem.type === "Physical coverage break") {
            if (((ref2 = node.per_nt) != null ? ref2.phys_cov : void 0) != null) {
              min = node.per_nt.phys_cov[problem.start];
              pos = problem.start;
              for (x = u = ref3 = problem.end, ref4 = problem.start; ref3 <= ref4 ? u < ref4 : u > ref4; x = ref3 <= ref4 ? ++u : --u) {
                if (!(node.per_nt.phys_cov[x] < min)) {
                  continue;
                }
                min = node.per_nt.phys_cov[x];
                pos = x;
              }
            }
            o.write("\t" + problem.type + "\t" + problem.start + "\t" + problem.end + "\t" + pos + "\n");
          } else if (problem.type === "Insert size anomaly") {
            if (((ref5 = node.per_nt) != null ? ref5.mp_ins : void 0) != null) {
              sign = (node.per_nt.mp_ins[problem.start] < node.per_nt.mp_ins[Math.round((problem.start + problem.end) / 2)]) ? 1 : -1;
              minmax = node.per_nt.mp_ins[problem.start];
              pos = problem.start;
              for (x = v = ref6 = problem.end, ref7 = problem.start; ref6 <= ref7 ? v < ref7 : v > ref7; x = ref6 <= ref7 ? ++v : --v) {
                if (!(sign * (node.per_nt.mp_ins[x] - minmax) > 0)) {
                  continue;
                }
                minmax = node.per_nt.mp_ins[x];
                pos = x;
              }
              magnitude = minmax - (node.per_nt.mp_ins[problem.start] + node.per_nt.mp_ins[problem.end]) / 2;
            }
            o.write("\t" + problem.type + "\t" + problem.start + "\t" + problem.end + "\t" + pos + "\t" + magnitude + "\n");
          } else {
            o.write("\t" + problem.type + "\t" + problem.start + "\t" + problem.end + "\n");
          }
        }
      }
    }
    o.write("\nProblem nodes: " + node_cnt + "\n");
    o.write("Total problems: " + total + "\n");
    o.write("Problem breakdown:\n");
    for (type in prob_types) {
      count = prob_types[type];
      o.write("\t" + type + ": " + count + "\n");
    }
    return o.end(function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };


  /*
   * Invoke tetracalc on current scaffolds, gather results
   */

  tetracalc = function(j, args, callback) {
    var cluster_json, options, tet;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Cluster scaffolds using the tetracalc tool");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n options : <string> -- Command line options for the tetracalc tool. Otherwise defaults used.\n \n NOTE: Run with --help for help with the settings offered by tetracalc.\n \n Example: " + args.help + " {\"options\":\"--merge_tar=0.95 -m 7500\"}\n \n Example: " + args.help + " {\"options\":\"--help\"}\n \n Example: " + args.help + " {\"options\":\"--fixed -t 0.9 -s 0.8 -r 0.9\"}\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (!((j.connected_comps != null) && (j.scaffolds != null))) {
      if (typeof callback === "function") {
        callback(new Error("No valid scaffolds found. Run SCAFF first."), null);
      }
      return;
    }
    if (!(Object.keys(j.scaffolds).length > 1)) {
      if (typeof callback === "function") {
        callback(new Error("There must be at least two scaffolds to run CLUST."), null);
      }
      return;
    }
    console.warn("CLUST: invoking tetracalc tool");
    cluster_json = "";
    if (args.options) {
      options = args.options.split(/\s+/);
      options.push('-');
    } else {
      options = ['-'];
    }
    tet = child_process.spawn('tetracalc', options, {});
    tet.stdout.setEncoding('ascii');
    tet.stderr.setEncoding('ascii');
    tet.stdout.on('data', function(data) {
      return cluster_json = cluster_json.concat(data);
    });
    tet.stderr.on('data', function(data) {
      return process.stderr.write(data);
    });
    tet.stdout.on('end', function() {
      var err;
      try {
        j.clusters = JSON.parse(cluster_json).clusters;
      } catch (error1) {
        err = error1;
        if (typeof callback === "function") {
          callback(new Error("Failed to parse output of tetracalc program. " + err.message), null);
        }
        return;
      }
      return typeof callback === "function" ? callback(null, j) : void 0;
    });
    tet.on('exit', function(code) {
      if (code) {
        console.error('ERROR: ' + code);
        return typeof callback === "function" ? callback(new Error('SEAStAR program "tetracalc" could not be executed. Please ensure that it is in your PATH'), null) : void 0;
      }
    });
    return export_fasta(j, {
      "scaff": true,
      "stream": tet.stdin,
      "verbose": args.verbose
    });
  };


  /*
   * Select clusters for output or further processing
   *
   * args (mutually exclusive):
   *
   * clustnum : Choose a cluster by number
   * clustnums : Choose a list of clusters
   * clustrange : Choose multiple clusters by a range of numbers
   * shift : Remove the first cluster
   *
   */

  grab_clusts = function(j, args, callback) {
    var cl, err, len, len1, m, new_cclist, new_clusts, new_scaffs, ref, ref1, ref2, ref3, results, scaf_id, u, v;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Select clusters of scaffolds for further processing");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n clustnum : <int> -- Select a specific cluster\n \n Example: " + args.help + " '{\"clustnum\":0}' -- select the first cluster\n \n clustnums : [<int1>, <int2>, ...] -- Select specific clusters\n \n Example: " + args.help + " '{\"clustnums\":[0,3,5]}' -- select these three clusters\n \n clustrange : [<int1>, <int2>] -- Select a range of clusters. See also: 'shift' option below.\n \n Example: " + args.help + " '{\"clustrange\":[0,5]}' -- select the first six clusters\n \n Example: " + args.help + " '{\"clustrange\":[-5,-1]}' -- select the last five clusters\n \n Example: " + args.help + " '{\"clustrange\":[0,-2]}' -- select all clusters except the\n last one\n \n shift : true -- Select all clusters except the first one.\n \n Example: " + args.help + " {\"shift\":true} -- Drop the first cluster.\n \n This is like " + args.help + " {\"clustrange\":[1,-1]} except it doesn't generate a\n fatal error when there is only one remaining cluster, allowing processing to\n potentially continue in any calling SCRIPT commands.\n \n exclusive : true -- Remove all scaffolds outside of the selected clusters\n \n Example: " + args.help + " '{\"exclusive\":false}' -- Default. Keep all unselected scaffolds.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (!((j.connected_comps != null) && (j.scaffolds != null) && (j.clusters != null))) {
      if (typeof callback === "function") {
        callback(new Error("No valid scaffold clusters found. Run CLUST first."), null);
      }
      return;
    }
    try {
      build_graph_refs(j);
    } catch (error1) {
      err = error1;
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.shift) {
      args.clustrange = [1, -1];
    }
    if (args.clustnum != null) {
      args.clustnums = [args.clustnum];
    } else if (args.clustrange != null) {
      if (args.clustrange[0] < 0) {
        args.clustrange[0] = j.clusters.length + args.clustrange[0];
      }
      if (args.clustrange[1] < 0) {
        args.clustrange[1] = j.clusters.length + args.clustrange[1];
      }
      args.clustnums = (function() {
        results = [];
        for (var m = ref = args.clustrange[0], ref1 = args.clustrange[1]; ref <= ref1 ? m <= ref1 : m >= ref1; ref <= ref1 ? m++ : m--){ results.push(m); }
        return results;
      }).apply(this);
    } else {
      if (args.clustnums == null) {
        args.clustnums = [0];
      }
    }
    new_cclist = [];
    new_clusts = [];
    new_scaffs = {};
    ref2 = args.clustnums;
    for (u = 0, len = ref2.length; u < len; u++) {
      cl = ref2[u];
      if (j.clusters[cl] == null) {
        remove_graph_refs(j);
        if (args.shift) {
          if (typeof callback === "function") {
            callback(null, void 0);
          }
        } else {
          if (typeof callback === "function") {
            callback(new Error("Invalid selected clustnum: " + cl + ". clustnums are zero-based and there are only " + j.clusters.length + " clusters in this graph."), null);
          }
        }
        return;
      }
      new_clusts.push(j.clusters[cl]);
      ref3 = j.clusters[cl];
      for (v = 0, len1 = ref3.length; v < len1; v++) {
        scaf_id = ref3[v];
        if (args.exclusive) {
          new_cclist.push(j.scaffolds[scaf_id].ccnum);
        }
        new_scaffs[scaf_id] = j.scaffolds[scaf_id];
      }
    }
    if (args.exclusive) {
      grab_ccomps(j, {
        "ccnums": new_cclist
      });
    }
    j.clusters = new_clusts;
    j.scaffolds = new_scaffs;
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * DUMP -- Output current JSON structure to a file
   *
   * args:
   *
   * file : Filename to write
   *
   */

  write_json = function(j, args, callback) {
    var o;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Output current data structure to a file, or by default to STDOUT");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.json[.gz]\" -- Specify a file name to write the JSON format sequence graph to.\n \n If the filename contains one or more `#` characters in a row, these positions are\n replaced with zero-padded digits that will increment each time a file is written to\n this filename pattern. If no `#` characters are present, then this command overwrites\n any existing file of the same name.\n \n Example: " + args.help + " {\"file\":\"my_assembly.json\"} -- Write data to the file\n my_assembly.json\n \n Example: " + args.help + " {\"file\":\"-\"} -- Write data piped to STDOUT (default)\n \n Example: " + args.help + " {\"file\":\"my_assembly_###.json\"} -- Write data to the file:\n my_assembly_000.json (first time this is run)\n \n Example: " + args.help + " {\"file\":\"my_assembly_###.json\"} -- Run again, write data\n to the file: my_assembly_001.json\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file, args.tag);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.file !== o.fn) {
      args.output = o.fn;
    }
    if (j.connected_comps == null) {
      if (j.scaffolds != null) {
        delete j.scaffolds;
      }
    }
    if (j.scaffolds == null) {
      if (j.clusters != null) {
        delete j.clusters;
      }
    }
    return my_stringify(j, o, 2, function(err) {
      if (err) {
        return typeof callback === "function" ? callback(err, null) : void 0;
      } else {
        return o.end(function(error) {
          if (error) {
            return typeof callback === "function" ? callback(error, null) : void 0;
          } else {
            return typeof callback === "function" ? callback(null, j) : void 0;
          }
        });
      }
    });
  };


  /*
   * read_json --
   *
   * args:
   *
   * file : Filename to read
   *
   */

  read_json = function(j, args, callback) {
    var cb, merge_edges, merge_graphs, ref, ref1, update_json;
    if (args == null) {
      args = {
        'file': '-'
      };
    }
    if (args.help != null) {
      console.warn(args.help + " -- Input JSON sequence graph data from a file, or by default from STDIN.");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename.json[.gz]\" -- Specify the name of a JSON format sequence graph file\n \n Example: " + args.help + " {\"file\":\"my_assembly.json\"} -- Read data from the file\n my_assembly.json\n \n Example: " + args.help + " {\"file\":\"-\"} -- Read data piped from STDIN (default)\n \n NOTE: On the command line, if the first parameter isn't a valid command string,\n and it ends in `.json[.gz]`, then it is assmued to be the name of a JSON file,\n and an implicit `LOAD` command will be run using that filename.\n \n files : [\"filename1.json[.gz]\", ...] -- Specify the names of multiple JSON format sequence\n graph files. The files must have uniquely named sequence nodes (contigs) with no\n nodes in common among the multiple files being loaded. Only the processing history\n from the first JSON file is retained (the other histories may still be found in their\n original files.)\n \n Example: " + args.help + " {\"files\":[\"my_assembly_1.json\",\"my_assembly_2.json\"]}\n -- Read data from the files my_assembly_1.json and my_assembly_2.json\n \n edges : \"edge_file.json[.gz]\" -- Specify the name of a JSON format sequence graph file to\n load edges and mate-pair statistics from. This option works with the 'file' option,\n and requires that the edge_file contain a graph with a subset of the nodes of the\n main graph being loaded with 'file'. Any edges and mate-pair statisics present in\n the main graph are discarded in favor of those from the edge_file.\n \n Example: " + args.help + " {\"file\":\"main_file.json\",\"edge_file\":\"edge_file.json\"}\n -- Read nodes and sequence data from main_file.json, and edges and connection data\n from edge_file.json\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (((ref = args.files) != null ? ref.length : void 0) && (args.file == null)) {
      args.file = args.files.shift();
    }
    update_json = function(old_json) {
      var n, nid, ref1, ref2, results, warn_flag;
      console.warn("Checking version of JSON input...");
      warn_flag = false;
      ref1 = old_json.nodes;
      results = [];
      for (nid in ref1) {
        n = ref1[nid];
        if (((ref2 = n.per_nt) != null ? ref2.seq : void 0) != null) {
          n.seq = n.per_nt.seq;
          delete n.per_nt.seq;
        }
        if ((n.recon_seq != null) || (n.per_nt_cov != null)) {
          if (!warn_flag) {
            console.warn("Version 0.4 JSON format detected.  Upgrading to newest version.");
            warn_flag = true;
          }
          if (n.per_nt == null) {
            n.per_nt = {};
          }
          if (n.recon_seq != null) {
            n.seq = n.recon_seq;
            delete n.recon_seq;
          }
          if (n.per_nt_cov != null) {
            n.per_nt.cov = n.per_nt_cov;
            delete n.per_nt_cov;
          }
          if (n.per_nt_phys_cov != null) {
            n.per_nt.phys_cov = n.per_nt_phys_cov;
            delete n.per_nt_phys_cov;
          }
          if (n.per_nt_mp_ins != null) {
            n.per_nt.mp_ins = n.per_nt_mp_ins;
            delete n.per_nt_mp_ins;
          }
          if (n.per_nt_mean_gc != null) {
            n.per_nt.mean_gc = n.per_nt_mean_gc;
            results.push(delete n.per_nt_mean_gc);
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    merge_graphs = function(err, graph) {
      var filename;
      filename = args.files.shift();
      return read_input_stream(filename, true, function(error, read_buffer) {
        var merge_graph, nid;
        if (error || !read_buffer) {
          console.error("ERROR: Empty buffer returned for file: " + filename);
          if (typeof callback === "function") {
            callback(error || new Error("Empty buffer returned for file: " + filename), null);
          }
        } else {
          update_json(read_buffer);
          merge_graph = read_buffer;
          if (merge_graph.nodes == null) {
            merge_graph.nodes = {};
          }
          if (merge_graph.removed_nodes == null) {
            merge_graph.removed_nodes = {};
          }
          if (merge_graph.edges == null) {
            merge_graph.edges = [];
          }
          if (merge_graph.internal_edges == null) {
            merge_graph.internal_edges = [];
          }
          if (merge_graph.removed_edges == null) {
            merge_graph.removed_edges = [];
          }
          if (merge_graph.shared_edges == null) {
            merge_graph.shared_edges = [];
          }
          for (nid in merge_graph.nodes) {
            if (graph.nodes[nid] != null) {
              console.error("ERROR: merge graph node " + nid + " already exists in main graph.");
              if (typeof callback === "function") {
                callback(new Error("ERROR: merge graph node " + nid + " already exists in main graph."), null);
              }
              return;
            } else {
              graph.nodes[nid] = merge_graph.nodes[nid];
            }
          }
          for (nid in merge_graph.removed_nodes) {
            if (graph.removed_nodes[nid] != null) {
              console.error("ERROR: merge graph removed node " + nid + " already exists in main graph.");
              if (typeof callback === "function") {
                callback(new Error("ERROR: merge graph removed node " + nid + " already exists in main graph."), null);
              }
              return;
            } else {
              graph.removed_nodes[nid] = merge_graph.removed_nodes[nid];
            }
          }
          graph.edges = graph.edges.concat(merge_graph.edges);
          graph.internal_edges = graph.internal_edges.concat(merge_graph.internal_edges);
          graph.removed_edges = graph.removed_edges.concat(merge_graph.removed_edges);
          graph.shared_seq_edges = graph.shared_seq_edges.concat(merge_graph.shared_seq_edges);
          if (args.files.length) {
            merge_graphs(null, graph);
          } else {
            if (graph.connected_comps != null) {
              delete graph.connected_comps;
            }
            if (graph.scaffolds != null) {
              delete graph.scaffolds;
            }
            if (graph.clusters != null) {
              delete graph.clusters;
            }
            if (graph.run_stats != null) {
              delete graph.run_stats;
            }
            if (graph.rollup_stats != null) {
              delete graph.rollup_stats;
            }
            return typeof callback === "function" ? callback(null, graph) : void 0;
          }
        }
      });
    };
    merge_edges = function(err, graph) {
      return read_input_stream(args.edges, true, function(error, read_buffer) {
        var e, edge_graph, en, gn, missing_nodes, nid, ref1, ref2, ref3, ref4;
        if (error || !read_buffer) {
          console.error("ERROR: Empty buffer returned for file: " + args.edges);
          if (typeof callback === "function") {
            callback(error || new Error("Empty buffer returned for file: " + args.edges), null);
          }
        } else {
          update_json(read_buffer);
          edge_graph = read_buffer;
          if (edge_graph.edges == null) {
            edge_graph.edges = [];
          }
          if (edge_graph.internal_edges == null) {
            edge_graph.internal_edges = [];
          }
          graph.merged_edges = true;
          missing_nodes = {};
          ref1 = edge_graph.nodes;
          for (nid in ref1) {
            en = ref1[nid];
            if (graph.nodes[nid] == null) {
              missing_nodes[nid] = true;
              console.warn("WARNING: edge graph node " + nid + " does not exist in main graph.");
            } else {
              gn = graph.nodes[nid];
              if (en.mp_pairs != null) {
                gn.mp_pairs = en.mp_pairs;
              }
              if (en.mp_fwd != null) {
                gn.mp_fwd = en.mp_fwd;
              }
              if (en.mp_bwd != null) {
                gn.mp_bwd = en.mp_bwd;
              }
              if (en.mp_ins_mean != null) {
                gn.mp_ins_mean = en.mp_ins_mean;
              }
              if (en.mp_ins_stdev != null) {
                gn.mp_ins_stdev = en.mp_ins_stdev;
              }
              if (en.per_nt != null) {
                if (gn.per_nt == null) {
                  gn.per_nt = {};
                }
              }
              if (((ref2 = en.per_nt) != null ? ref2.phys_cov : void 0) != null) {
                gn.per_nt.phys_cov = en.per_nt.phys_cov;
              }
              if (((ref3 = en.per_nt) != null ? ref3.mp_ins : void 0) != null) {
                gn.per_nt.mp_ins = en.per_nt.mp_ins;
              }
              gn.merge_stats = {};
              if (en.bits != null) {
                gn.merge_stats.bits = en.bits;
              }
              if (en.rd_cnt != null) {
                gn.merge_stats.rd_cnt = en.rd_cnt;
              }
              if (en.int_cov != null) {
                gn.merge_stats.int_cov = en.int_cov;
              }
              if (en.rel_ab != null) {
                gn.merge_stats.rel_ab = en.rel_ab;
              }
              if (en.cov != null) {
                gn.merge_stats.cov = en.cov;
              }
              if (en.pct_uncov != null) {
                gn.merge_stats.pct_uncov = en.pct_uncov;
              }
              if (en.rd_len != null) {
                gn.merge_stats.rd_len = en.rd_len;
              }
              if (en.adj_cov != null) {
                gn.merge_stats.adj_cov = en.adj_cov;
              }
              if (en.adj_cov_stddev != null) {
                gn.merge_stats.adj_cov_stddev = en.adj_cov_stddev;
              }
              if (en.adj_cov_min != null) {
                gn.merge_stats.adj_cov_min = en.adj_cov_min;
              }
              if (en.adj_cov_max != null) {
                gn.merge_stats.adj_cov_max = en.adj_cov_max;
              }
              if (((ref4 = en.per_nt) != null ? ref4.cov : void 0) != null) {
                gn.merge_stats.per_nt = {
                  cov: en.per_nt.cov
                };
              }
            }
          }
          graph.edges = (function() {
            var len, m, ref5, results;
            ref5 = edge_graph.edges;
            results = [];
            for (m = 0, len = ref5.length; m < len; m++) {
              e = ref5[m];
              if (!((missing_nodes[e.n1] != null) || (missing_nodes[e.n2] != null))) {
                results.push(e);
              }
            }
            return results;
          })();
          graph.internal_edges = (function() {
            var len, m, ref5, results;
            ref5 = edge_graph.internal_edges;
            results = [];
            for (m = 0, len = ref5.length; m < len; m++) {
              e = ref5[m];
              if (!((missing_nodes[e.n1] != null) || (missing_nodes[e.n2] != null))) {
                results.push(e);
              }
            }
            return results;
          })();
          graph.removed_edges = [];
          return typeof callback === "function" ? callback(null, graph) : void 0;
        }
      });
    };
    if ((ref1 = args.files) != null ? ref1.length : void 0) {
      cb = merge_graphs;
    } else if (args.edges != null) {
      cb = merge_edges;
    } else {
      cb = callback;
    }
    return read_input_stream(args.file, true, function(error, read_buffer) {
      if (error || !read_buffer) {
        console.error("ERROR: Empty buffer returned for file: " + args.file);
        if (typeof callback === "function") {
          callback(error || new Error("Empty buffer returned for file: " + args.file), null);
        }
      } else {
        update_json(read_buffer);
        j = read_buffer;
        if (j.processing == null) {
          j.processing = [];
        }
        if (j.nodes == null) {
          j.nodes = {};
        }
        if (j.removed_nodes == null) {
          j.removed_nodes = {};
        }
        if (j.edges == null) {
          j.edges = [];
        }
        if (j.internal_edges == null) {
          j.internal_edges = [];
        }
        if (j.shared_seq_edges == null) {
          j.shared_seq_edges = [];
        }
        if (j.removed_edges == null) {
          j.removed_edges = [];
        }
        j.merged_edges = false;
        j.processing.push(["$", ss_version, 'LOAD', clone_object(args)]);
        return typeof cb === "function" ? cb(null, j) : void 0;
      }
    });
  };


  /*
   * command_file -- Implementation of the SCRIPT command
   */

  command_file = function(j, args, callback) {
    var queue_commands;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Use contents of file as a series of commands, or read from the console if\n no file provided");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n file : \"filename[.gz]\" -- Read commands from the named file\n \n Example: " + args.help + " {\"file\":\"my_script.go\"} -- Read and run commands from\n the file my_script.go\n \n Example: " + args.help + " -- Enter an interactive (command line) session at this point\n typing commands one at a time\n \n self : true -- Causes a SCRIPT file to recursively call itself.\n \n Example: " + args.help + " {\"self\":true} -- Read and run commands from\n the same file that this command was invoked from. So that file was my_script.go\n this command behaves identically to using: {\"file\":\"my_script.go\"}\n \n tag : \"filename_part\" -- Part of a filename to include in files written from this script\n NOTE: tag renaming is not used within interactive SCRIPT command sessions.\n \n Example: " + args.help + " {\"file\":\"my_script.go\", \"tag\":\"Run1\"} -- Add the \n string \"Run1\" in place of the '@' character in the filenames of any output files\n written by commands in the script my_script.go (e.g. \"@_output.json\" would\n become \"Run1_output.json\").\n \n Example: " + args.help + " {\"file\":\"my_script.go\", \"tag\":\"Sample_A\"} -- Add the \n string \"Sample_A\" in place of runs of '@' characters anywhere in the file path\n of files written by commands in the script my_script.go, for example:\n \"~/data/samples/@@@/@@@_output.json\" would become:\n \"~/data/samples/Sample_A/Sample_A_output.json\"\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    queue_commands = function(error, read_buffer) {
      var argstr, cmd, cmd_args, cmdparts, err, l, len, lines, m, script_cmds, script_next_cmd, tag_rep;
      if (error || !read_buffer) {
        if (typeof callback === "function") {
          callback(error || new Error("empty read_buffer after reading SCRIPT file."), null);
        }
        return;
      }
      lines = read_buffer.split("\n");
      script_cmds = [];
      for (m = 0, len = lines.length; m < len; m++) {
        l = lines[m];
        cmdparts = l.trim().replace(/\t/, " ").split(" ");
        cmd = cmdparts[0];
        cmd = cmd.toUpperCase();
        argstr = cmdparts.length > 1 ? cmdparts.slice(1).join(" ") : null;
        if (typeof commands[cmd] === 'function') {
          if (argstr) {
            try {
              cmd_args = JSON.parse(argstr);
            } catch (error1) {
              err = error1;
              console.error("ERROR: Could not parse JSON arguments '" + argstr + "' to '" + cmd + "' command");
              if (typeof callback === "function") {
                callback(err, null);
              }
              return;
            }
          } else {
            cmd_args = null;
          }
          if (((cmd_args != null ? cmd_args.file : void 0) != null) && (args.tag != null) && !(cmd === 'LOAD')) {
            if (cmd_args.tag == null) {
              cmd_args.tag = args.tag;
            }
          }
          if (cmd === 'SCRIPT') {
            if (!(((cmd_args != null ? cmd_args.file : void 0) != null) || ((cmd_args != null ? cmd_args.self : void 0) != null))) {
              if (typeof callback === "function") {
                callback(new Error("Invalid command: You may not launch an interactive SCRIPT session from within a SCRIPT."), null);
              }
              return;
            }
            if ((cmd_args != null ? cmd_args.self : void 0)) {
              cmd_args.file = args.file;
              if (args.tag != null) {
                if (cmd_args.tag == null) {
                  cmd_args.tag = args.tag;
                }
              }
              console.warn("INFO: SCRIPT '" + args.file + "' recursively calling itself with tag '" + cmd_args.tag + "'");
            }
            if (((cmd_args != null ? cmd_args.tag : void 0) != null) && (tag_rep = cmd_args.tag.match(/(@+)/))) {
              if (args.tag == null) {
                if (typeof callback === "function") {
                  callback(new Error("SCRIPT: Couldn't substitute for '" + tag_rep[1] + "' in tag '" + cmd_args.tag + "' because caller didn't provide a tag."), null);
                }
                return;
              } else {
                console.warn("INFO: Substituting '" + args.tag + "' for '" + tag_rep[1] + "' in tag '" + cmd_args.tag + "'");
                cmd_args.tag = cmd_args.tag.replace(/@+/g, args.tag);
              }
            }
          }
          script_cmds.push([commands[cmd], cmd_args, cmd]);
        } else if (cmd && cmd[0] !== '#') {
          if (typeof callback === "function") {
            callback(new Error("Invalid command: '" + cmd + "'"), null);
          }
          return;
        }
      }
      read_buffer = null;
      script_next_cmd = function(err, return_j) {
        var cmd_func, err_str, ref, ref1;
        if (err) {
          err_str = "SCRIPT aborted due to error in command execution.";
          if (err.message !== no_data_str) {
            if (err.message !== err_str) {
              console.error("ERROR terminating SCRIPT processing: " + err.message + "\n");
              err = Error(err_str);
            }
            if (typeof callback === "function") {
              callback(err, null);
            }
            return;
          }
        }
        if (script_cmds.length) {
          ref = script_cmds.shift(), cmd_func = ref[0], cmd_args = ref[1], cmd = ref[2];
          if (!(((return_j != null ? return_j.nodes : void 0) != null) || cmd === 'LOAD' || cmd === 'SCRIPT' || cmd === 'UNSTASH' || cmd === 'HELP')) {
            if (typeof callback === "function") {
              callback(new Error(no_data_str), {
                "processing": (j != null ? j.processing : void 0) || []
              });
            }
            return;
          }
          if (cmd !== 'HELP') {
            if (return_j != null) {
              if ((ref1 = return_j.processing) != null) {
                ref1.push([args.file, ss_version, cmd, clone_object(cmd_args)]);
              }
            }
          }
          console.warn("Executing (" + args.file + ") " + cmd + " " + (JSON.stringify(cmd_args)));
          return setImmediate(cmd_func, return_j, cmd_args, script_next_cmd);
        } else {
          return typeof callback === "function" ? callback(null, return_j) : void 0;
        }
      };
      return script_next_cmd(null, j);
    };
    if (args.file != null) {
      return read_input_stream(args.file, false, queue_commands);
    } else {
      if (!((process.stderr._type != null) && process.stderr._type === 'tty')) {
        console.log("ERROR: Interactive use of the SCRIPT command requires that STDERR not be redirected.\n");
        if (typeof callback === "function") {
          callback(new Error("Interactive use of the SCRIPT command requires that STDERR not be redirected."), null);
        }
        return;
      }
      console.warn("\nEntering interactive SCRIPT mode, SEAStAR Version: " + ss_version + "\nFor general help, quit and rerun with the -h option. Type 'HELP' for help with commands.\nType '.save <filename>' to save commands from this session to an output file.\nPress <Ctrl-D> to quit.\n");
      if ((process.stdout._type != null) && process.stdout._type !== 'tty') {
        console.warn("NOTE: You appear to be redirecting the output of this session, no interactive command results will be visible.\n");
      }
      return repl.start({
        prompt: ">> ",
        output: process.stderr,
        input: process.stdin,
        terminal: true,
        ignoreUndefined: true,
        "eval": function(l, cx, fn, cb) {
          var arg_json, argstr, cmd, cmd_func, err, ref;
          if (l[0] === '(' && l.slice(-1) === ')') {
            l = l.slice(1, -1);
          }
          ref = l.trim().replace(/\t|\n/, " ").split(" "), cmd = ref[0], argstr = 2 <= ref.length ? slice.call(ref, 1) : [];
          argstr = argstr.join(' ').replace(/^['"]|["']$/g, "");
          cmd = cmd.toUpperCase();
          if (cmd === 'HELP') {
            cmd_func = commands[cmd];
            if (argstr != null ? argstr.match(/{.*}/) : void 0) {
              try {
                arg_json = JSON.parse(argstr);
              } catch (error1) {
                err = error1;
                console.error("\nERROR: Could not parse JSON arguments '" + argstr + "' to '" + cmd + "' command\n");
                cb(null, void 0);
                return;
              }
              return setImmediate(cmd_func, j, arg_json, function(j) {
                return cb(null, void 0);
              });
            } else {
              return setImmediate(cmd_func, j, {
                'topic': argstr
              }, function(j) {
                return cb(null, void 0);
              });
            }
          } else if (typeof commands[cmd] === 'function') {
            if (argstr) {
              try {
                args = JSON.parse(argstr);
              } catch (error1) {
                err = error1;
                console.warn("\nInvalid arguments '" + argstr + "' to '" + cmd + "'. Could not parse JSON string.\n");
                cb(null, void 0);
                return;
              }
            } else {
              args = null;
            }
            if ((cmd === 'SCRIPT') && ((args != null ? args.file : void 0) == null)) {
              console.warn("\nInvalid command: You may not launch nested interactive SCRIPT sessions.\n");
              return cb(null, void 0);
            } else if (!((((j != null ? j.nodes : void 0) != null) || cmd === 'LOAD' || cmd === 'SCRIPT' || cmd === 'UNSTASH') || cmd === 'HELP')) {
              console.warn("\nERROR: No data is currently loaded. Use the LOAD command to read a datafile\n");
              return cb(null, void 0);
            } else {
              cmd_func = commands[cmd];
              return setImmediate(cmd_func, j, args, function(err, return_j) {
                var ref1;
                if (err) {
                  console.error("ERROR: " + err.message + "\n");
                  console.warn("\nCommand failed: Please examine the above error messages and try again.\n");
                } else if (!return_j) {
                  console.warn("\nWARNING: Previous command returned no output.\n");
                  j = {
                    "processing": (j != null ? j.processing : void 0) || []
                  };
                } else {
                  j = return_j;
                  if (j != null) {
                    if ((ref1 = j.processing) != null) {
                      ref1.push([">>", ss_version, cmd, clone_object(args)]);
                    }
                  }
                }
                return cb(null, void 0);
              });
            }
          } else {
            if (cmd) {
              console.warn("\nInvalid command: '" + cmd + "'\n");
            }
            return cb(null, void 0);
          }
        }
      }).on('exit', function() {
        console.warn("\n");
        return typeof callback === "function" ? callback(null, j) : void 0;
      });
    }
  };


  /*
   * output_help -- Implementation of the HELP command
   */

  output_help = function(j, args, callback) {
    var c, cmd_list;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- List all valid commands, or provide detailed help for a specific command\n with " + args.help + " <COMMAND>");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n topic : \"command\" -- Provide detailed help for a specific command.\n \n Example: " + args.help + " {\"topic\":\"" + args.help + "\"} -- Provide help about the\n " + args.help + " command itself\n \n Using the special word 'ALL' (which is not a valid command) in place of the\n command string will cause detailed help to be printed for all commands.\n \n Example: " + args.help + " {\"topic\":\"ALL\"} -- Provide detail help about commands\n \n NOTE: The " + args.help + " command when used as the first and only command on the\n command-line (or within an interactive SCRIPT session) may include the topic\n command directly as the second command line parameter\n \n Example: " + args.help + " " + args.help + " is equivalent to " + args.help + " {\"topic\":\"" + args.help + "\"} in this situation\n \n cmd_line : true -- Provide detailed help for UNIX shell command line use.\n \n Example: " + args.help + " {\"cmd_line\":\"true\"} -- UNIX command line help.\n \n This help can also be obtained from the shell by running with the -h option.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    cmd_list = function() {
      var c;
      for (c in commands) {
        if (typeof commands[c] === 'function') {
          commands[c](j, {
            'help': c
          });
        } else {
          console.warn(commands[c]);
        }
      }
      return console.warn('');
    };
    if (args.topic != null) {
      args.topic = args.topic.toUpperCase();
      if (typeof commands[args.topic] === 'function') {
        console.warn('');
        commands[args.topic](j, {
          'help': args.topic,
          'detailed_help': true
        });
      } else if (args.topic.toUpperCase() === 'ALL') {
        cmd_list();
        for (c in commands) {
          if (typeof commands[c] === 'function') {
            console.warn('==========================================================================================\n');
            commands[c](j, {
              'help': c,
              'detailed_help': true
            });
          }
        }
      } else {
        console.warn("\nCommand '" + args.topic + "' not found, please select a valid command from below:\n");
        cmd_list();
      }
    } else if (args.cmd_line != null) {
      console.warn(commands['prelude1'] + " \n Usage: graph_ops [<input.json[.gz]>] [<script.go[.gz]>] [<command> ['{params}']]...\n \n where: <input.json[.gz]> is an optional datafile to initially LOAD\n <script.go[.gz]> is an optional SCRIPT to initially execute\n <command> is a valid command (see below)\n '{params}' optionally specify parameters for a given command\n \n Multiple commands with optional parameters may be provided in succession for execution.\n \n Running this program without any options will launch an interactive mode,\n equivalent to:  graph_ops SCRIPT\n \n For a list of valid commands: use: graph_ops HELP\n \n For detailed help for a specific command, use: graph_ops HELP <command>\n \n SEAStAR Version: " + ss_version + "\n");
    } else {
      cmd_list();
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * push_stash --
   */

  push_stash = function(j, args, callback) {
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Copy (push) the current graph to the top of a stack in memory");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:  None.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    stash_stack.push(clone_object(j));
    console.warn(stash_stack.length + " graph" + (stash_stack.length !== 1 ? 's' : '') + " in stash.");
    return typeof callback === "function" ? callback(null, j) : void 0;
  };


  /*
   * pop_stash --
   */

  pop_stash = function(j, args, callback) {
    var hist;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn(args.help + " -- Restore (pop) the current graph from the top of the stack (undo changes)");
      if (args.detailed_help != null) {
        console.warn("\n Parameters:\n \n free : true -- Free the graph at the top of the stack without restoring its state.\n \n Example: " + args.help + " {\"free\":true} -- Discard most recently STASHed graph\n \n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (!(stash_stack.length > 0)) {
      if (typeof callback === "function") {
        callback(new Error("UNSTASH failed, stash is empty."), null);
      }
    } else {
      if (args.free) {
        stash_stack.pop();
      } else {
        hist = j.processing || [];
        j = void 0;
        j = stash_stack.pop();
        j.processing = hist;
      }
      console.warn(stash_stack.length + " graph" + (stash_stack.length !== 1 ? 's' : '') + " remain" + (stash_stack.length === 1 ? 's' : '') + " in stash.");
      return typeof callback === "function" ? callback(null, j) : void 0;
    }
  };


  /*
   * ************************************************************************
   * Mapping of command strings to implememnting functions defined above
   *
   * All functions below implement the same calling interface:
   *
   * function(j, args, callback), where:
   *
   * j        :  the JSON graph object to work on
   * args     :  an object of arguments to this command
   * callback :  a function to call when the operation is complete
   *
   */

  commands = {
    'prelude1': '\n This program reads json format data files produced by the SEAStAR ref_select program.\n It implements a variety of commands for manipulating this data for assembly,\n visualization or output to a variety of file formats.\n',
    'prelude2': 'For help with UNIX command line options, run the program with -h or --help\n\n All commands below accept parameters in the form: {"parm1":value1,"parm2":value2...}\n For examples and/or detailed help with specific commands, type:  HELP <command>\n',
    'spacer1': '===============================',
    'text1': 'File I/O commands\n',
    'LOAD': read_json,
    'DUMP': write_json,
    'TABLE': export_table,
    'FASTA': export_fasta,
    'DOT': export_dot,
    'spacer2': '\n===============================',
    'text2': 'Assembly pipeline commands (in this order)\n',
    'MST': maximal_spanning_tree,
    'SST': scaffold_spanning_tree,
    'text3': '   *** SST is an optional replacement for MST, useful for metagenomes',
    'text3a': '   *** or relatively short contigs',
    'PLUCK': remove_leaves,
    'PRUNE': cut_branches,
    'SLICE': check_connections,
    'text4': '   *** SLICE is optional, but recommended for metagenomes',
    'PUSH': add_ends,
    'INSERT': full_order,
    'SCAFF': scaffold,
    'CLUST': tetracalc,
    'spacer3': '\n===============================',
    'text6': 'Assembly graph filter/edit utilities\n',
    'CIRCLE': circles,
    'CCOMPS': calc_ccomps,
    'SELCC': grab_ccomps,
    'SELCLUST': grab_clusts,
    'SELND': grab_neighbors,
    'SCAFLNK': scaff_link,
    'RELINK': relink,
    'EDGFLT': filter_edges,
    'PROBS': node_problems,
    'EDIT': perform_edits,
    'CUTND': cut_node,
    'spacer4': '\n===============================',
    'text7': 'Information and control\n',
    'GC': graph_stats,
    'GCC': graph_stats_cc,
    'STASH': push_stash,
    'UNSTASH': pop_stash,
    'SCRIPT': command_file,
    'HELP': output_help
  };


  /*
   * This function gets called once the entire JSON data structure is available
   * It parses the commandline options and builds a callback_list that is used
   * to chain command calls together in an 'event driven' friendly manner.
   * It ends by calling the first command on the list via the call_next_cmd function.
   */

  process_commands = function(callback_list) {
    var call_next_cmd, json;
    json = {};
    call_next_cmd = function(err, j) {
      var cmd, cmd_args, cmd_func, ref, ref1;
      if (err) {
        console.error("ERROR: " + err.message + "\n");
        process.exit(1);
      }
      if (callback_list.length) {
        ref = callback_list.shift(), cmd_func = ref[0], cmd_args = ref[1], cmd = ref[2];
        if (!(((j != null ? j.nodes : void 0) != null) || cmd === 'LOAD' || cmd === 'SCRIPT' || cmd === 'UNSTASH' || cmd === 'HELP')) {
          console.error("ERROR: No data, ending command line processing.\n");
          process.exit(1);
        }
        if (cmd !== 'HELP') {
          if (j != null) {
            if ((ref1 = j.processing) != null) {
              ref1.push(["$", ss_version, cmd, clone_object(cmd_args)]);
            }
          }
        }
        console.warn("Executing " + cmd + " " + (JSON.stringify(cmd_args)));
        return setImmediate(cmd_func, j, cmd_args, call_next_cmd);
      }
    };
    return call_next_cmd(null, json);
  };


  /*
   * Handle commandline args
   */

  cmds = [];

  callback_list = [];

  if (process.argv.length < 3) {
    callback_list.push([commands['SCRIPT'], {}, 'SCRIPT']);
  } else if (process.argv[2].toUpperCase() === 'HELP') {
    if (process.argv[3] != null) {
      if (process.argv[3].match(/{.*}/)) {
        callback_list.push([commands['HELP'], JSON.parse(process.argv[3]), 'HELP']);
      } else {
        callback_list.push([
          commands['HELP'], {
            'topic': process.argv[3]
          }, 'HELP'
        ]);
      }
    } else {
      callback_list.push([commands['HELP'], {}, 'HELP']);
    }
  } else if (process.argv[2].match(/^-?-h(elp)?$/i)) {
    callback_list.push([
      commands['HELP'], {
        'cmd_line': true
      }, 'HELP'
    ]);
  } else {
    start_arg = 2;
    if (!((process.argv[2].toUpperCase() === 'LOAD') || (process.argv[2].toUpperCase() === 'SCRIPT'))) {
      if (process.argv[2].match(/^(-|(.+\.json(\.gz)?))$/)) {
        callback_list.push([
          commands['LOAD'], {
            'file': process.argv[2]
          }, 'LOAD'
        ]);
        start_arg++;
        if (process.argv[start_arg] == null) {
          process.argv[start_arg] = 'SCRIPT';
        }
      }
      if (process.argv[start_arg].match(/.+\.go(\.gz)?$/)) {
        callback_list.push([
          commands['SCRIPT'], {
            'file': process.argv[start_arg]
          }, 'SCRIPT'
        ]);
        start_arg++;
      }
    }
    prev_cmd = false;
    ref = process.argv.slice(start_arg);
    for (m = 0, len = ref.length; m < len; m++) {
      cmd = ref[m];
      if (prev_cmd && cmd.match(/{.*}/)) {
        try {
          callback_list.slice(-1)[0][1] = JSON.parse(cmd);
        } catch (error1) {
          err = error1;
          console.error("ERROR: Could not parse JSON arguments '" + cmd + "' to " + callback_list.slice(-1)[0][2] + " command");
          process.exit(1);
        }
        prev_cmd = false;
      } else if (typeof commands[cmd.toUpperCase()] === 'function') {
        cmd = cmd.toUpperCase();
        callback_list.push([commands[cmd], null, cmd]);
        prev_cmd = true;
      } else {
        console.error("ERROR: Invalid command line command: '" + cmd + "'\n");
        process.exit(1);
      }
    }
  }

  process_commands(callback_list);

}).call(this);
