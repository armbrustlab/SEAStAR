// Generated by CoffeeScript 1.12.7

/*
 * -------------------------------------------------------------------------- #
 * Center for Environmental Genomics
 * Copyright (C) 2012-2013 University of Washington.
 *
 * Authors:
 * Vaughn Iverson
 * vsi@uw.edu
 * -------------------------------------------------------------------------- #
 * This file is part of SEAStAR.
 *
 * SEAStAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SEAStAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
 * -------------------------------------------------------------------------- #
 */

(function() {
  var cmds, fs, gap_pad, heal_fn, heal_m, heal_max, heal_n, heal_seq, heal_string, input, inputfn, output, overlap_m, overlap_max, overlap_n, p, parm, process_heal_fasta, process_scaffs, rc_tab, rev_comp, scaff_string, scaffs, ss_version, ver, verbose, zlib,
    slice = [].slice;

  ver = process.version.slice(1).split('.');

  if (!(ver[1] >= 10 || ver[0] > 0)) {
    console.error("ERROR: nodejs version v0.10.0 or greater required.");
    process.exit(1);
  }

  verbose = false;

  fs = require('fs');

  zlib = require('zlib');

  ss_version = "SS_BUILD_VERSION";

  scaff_string = '';

  heal_string = '';

  rc_tab = {
    'A': 'T',
    'T': 'A',
    'G': 'C',
    'C': 'G',
    'X': 'X',
    'M': 'K',
    'K': 'M',
    'R': 'Y',
    'Y': 'R',
    'W': 'S',
    'S': 'W',
    'V': 'B',
    'B': 'V',
    'H': 'D',
    'D': 'H',
    'N': 'N',
    '\n': '\n'
  };

  heal_seq = '';

  scaffs = [];

  rev_comp = function(st) {
    return st.split("").reverse().map(function(b) {
      return rc_tab[b];
    }).join("");
  };


  /*
   * Format the alternate assembly sequences used to "heal" gaps in the main scaffolds
   */

  process_heal_fasta = function(fasta) {
    var s;
    heal_seq = ((function() {
      var k, len, ref, results;
      ref = fasta.split(">");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        s = ref[k];
        results.push(s.split("\n").slice(1).join("").toUpperCase());
      }
      return results;
    })()).join("\n");
    return heal_seq = rev_comp(heal_seq) + "\n" + heal_seq;
  };


  /*
   * Process the scaffolds and write out the results.
   */

  process_scaffs = function(fasta) {
    var c, cf, cfmax, contig, cr, crmax, frame, i, i1, j, j1, k, k1, l, l1, len, len1, len2, len3, len4, len5, len6, len7, len8, m, m1, match, max, n, n1, name, ns, num_contigs, o, o1, overlap, pad, pf, pfmax, pr, prev_contig, prmax, q, r, rc, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, rev_contig, rev_prev_contig, rp, s, scaf, scaf_ind, scaff_cnt, scaff_names, scaff_num, scaff_nums, scafout, seqs, t, trim_match, u, v, w, x, y, z;
    num_contigs = [];
    scaff_cnt = 0;
    scaff_nums = {};
    scaff_names = [];
    ref = fasta.split(">").slice(1);
    for (k = 0, len = ref.length; k < len; k++) {
      s = ref[k];
      ref1 = s.split(/\n| /), name = ref1[0], scaff_string = ref1[1], seqs = 3 <= ref1.length ? slice.call(ref1, 2) : [];
      if (scaff_nums[scaff_string] == null) {
        scaff_nums[scaff_string] = scaff_cnt;
        scaff_names[scaff_cnt] = scaff_string;
        scaff_cnt++;
      }
      scaff_num = scaff_nums[scaff_string];
      if (scaffs[scaff_num] == null) {
        scaffs[scaff_num] = [];
      }
      if (num_contigs[scaff_num] == null) {
        num_contigs[scaff_num] = 0;
      }
      trim_match = seqs.join("").toUpperCase().match(/[ACGT]{10}.*[ACGT]{10}/);
      if (trim_match) {
        scaffs[scaff_num].push(trim_match[0]);
        num_contigs[scaff_num]++;
      }
    }
    n = overlap_n;
    m = overlap_m;
    max = overlap_max;
    for (x = o = 0, len1 = scaffs.length; o < len1; x = ++o) {
      scaf = scaffs[x];
      if (scaf) {
        for (y = q = 0, len2 = scaf.length; q < len2; y = ++q) {
          contig = scaf[y];
          if (!(y)) {
            continue;
          }
          prev_contig = scaf[y - 1];
          l = prev_contig.length;
          for (i = t = ref2 = max, ref3 = n; ref2 <= ref3 ? t <= ref3 : t >= ref3; i = ref2 <= ref3 ? ++t : --t) {
            c = 0;
            for (j = u = 0, ref4 = i; 0 <= ref4 ? u < ref4 : u > ref4; j = 0 <= ref4 ? ++u : --u) {
              if (prev_contig.substr(l - i + j, 1) === contig.substr(j, 1)) {
                c++;
              } else if ((c < n) || (c < i - (2 * m))) {
                c = 0;
              } else {
                break;
              }
            }
            if ((c >= n) && (c >= i - (2 * m))) {
              overlap = prev_contig.substr(l - i + (j - c), c).toLowerCase();
              scaf[y] = prev_contig.substr(0, l - i + (j - c)) + overlap + contig.substr(c + (j - c));
              delete scaf[y - 1];
              if (verbose) {
                console.warn("**** Found match! %d %d %d %d %d", x, y, i, j, c);
                console.warn("%s", prev_contig.substr(l - max + 1));
                pad = '';
                for (x = v = 1, ref5 = max - i + (j - c); 1 <= ref5 ? v < ref5 : v > ref5; x = 1 <= ref5 ? ++v : --v) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, overlap);
                pad = '';
                for (x = w = 1, ref6 = max - i; 1 <= ref6 ? w < ref6 : w > ref6; x = 1 <= ref6 ? ++w : --w) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, contig.substr(0, max));
              }
              break;
            } else {
              c = 0;
            }
          }
        }
      }
    }
    for (x = z = 0, len3 = scaffs.length; z < len3; x = ++z) {
      scaf = scaffs[x];
      if (scaf) {
        scaffs[x] = (function() {
          var i1, len4, results;
          results = [];
          for (i1 = 0, len4 = scaf.length; i1 < len4; i1++) {
            contig = scaf[i1];
            if (contig != null) {
              results.push(contig);
            }
          }
          return results;
        })();
      }
    }
    if (heal_seq) {
      n = heal_n;
      m = heal_m;
      max = heal_max;
      for (scaf_ind = i1 = 0, len4 = scaffs.length; i1 < len4; scaf_ind = ++i1) {
        scaf = scaffs[scaf_ind];
        if (scaf) {
          for (y = j1 = 0, len5 = scaf.length; j1 < len5; y = ++j1) {
            contig = scaf[y];
            if (!(y)) {
              continue;
            }
            prev_contig = scaf[y - 1];
            l = prev_contig.length;
            r = (prev_contig.substr(-(n + m), n)) + "([^\n]{1," + max + "})" + (contig.substr(m, n));
            if (match = heal_seq.match(r)) {
              overlap = match[1].toLowerCase();
              scaf[y] = prev_contig.substr(0, l - m) + overlap + contig.substr(m);
              delete scaf[y - 1];
              if (verbose) {
                console.warn("**** Found match! %d %d", scaf_ind, y);
                console.warn("%s", prev_contig.substr(-(n + m)));
                pad = '';
                console.warn("%s%s%s", prev_contig.substr(-(n + m), n), overlap, contig.substr(m, n));
                for (x = k1 = 1, ref7 = n + overlap.length - m; 1 <= ref7 ? k1 <= ref7 : k1 >= ref7; x = 1 <= ref7 ? ++k1 : --k1) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, contig.substr(0, m + n));
              }
            }
          }
        }
      }
    }
    for (x = l1 = 0, len6 = scaffs.length; l1 < len6; x = ++l1) {
      scaf = scaffs[x];
      if (scaf) {
        scaffs[x] = (function() {
          var len7, m1, results;
          results = [];
          for (m1 = 0, len7 = scaf.length; m1 < len7; m1++) {
            contig = scaf[m1];
            if (contig != null) {
              results.push(contig);
            }
          }
          return results;
        })();
      }
    }
    rp = /(?:(?:[^T]..)|(?:T(?:(?:[^AG].)|(?:G[^A])|(?:A[^GA]))))+$/;
    rc = /^(?:(?:[^T]..)|(?:T(?:(?:[^AG].)|(?:G[^A])|(?:A[^GA]))))+/;
    ns = ['', 'N', 'NN'];
    results = [];
    for (x = m1 = 0, len7 = scaffs.length; m1 < len7; x = ++m1) {
      scaf = scaffs[x];
      if (!((scaf != null ? scaf[0] : void 0) != null)) {
        continue;
      }
      scafout = scaf[0];
      prev_contig = scaf[0];
      rev_prev_contig = rev_comp(prev_contig);
      for (y = n1 = 0, len8 = scaf.length; n1 < len8; y = ++n1) {
        contig = scaf[y];
        if (!(y)) {
          continue;
        }
        rev_contig = rev_comp(contig);
        pfmax = [-1, -1];
        cfmax = [-1, -1];
        prmax = [-1, -1];
        crmax = [-1, -1];
        for (n = o1 = 0; o1 <= 2; n = ++o1) {
          pf = (ref8 = (ref9 = (prev_contig + ns[n]).match(rp)) != null ? ref9[0].length : void 0) != null ? ref8 : 0;
          if (pf > pfmax[1]) {
            pfmax = [n, pf];
          }
          cf = (ref10 = (ref11 = (ns[n] + contig).match(rc)) != null ? ref11[0].length : void 0) != null ? ref10 : 0;
          if (cf > cfmax[1]) {
            cfmax = [n, cf];
          }
          pr = (ref12 = (ref13 = (ns[n] + rev_prev_contig).match(rc)) != null ? ref13[0].length : void 0) != null ? ref12 : 0;
          if (pr > prmax[1]) {
            prmax = [n, pr];
          }
          cr = (ref14 = (ref15 = (rev_contig + ns[n]).match(rp)) != null ? ref15[0].length : void 0) != null ? ref14 : 0;
          if (cr > crmax[1]) {
            crmax = [n, cr];
          }
        }
        if (pfmax[1] + cfmax[1] > prmax[1] + crmax[1]) {
          frame = (pfmax[0] + cfmax[0]) % 3;
        } else {
          frame = (prmax[0] + crmax[0]) % 3;
        }
        scafout = scafout + gap_pad + ns[frame] + contig;
        prev_contig = contig;
        rev_prev_contig = rev_contig;
      }
      process.stdout.write(">" + scaff_names[x] + "\n");
      process.stdout.write(scafout);
      results.push(process.stdout.write("\n"));
    }
    return results;
  };


  /*
   * Handle command args and process input files
   */

  output = process.stdout;

  cmds = [];

  heal_fn = null;

  heal_n = 29;

  heal_m = 5;

  heal_max = 500;

  overlap_n = 6;

  overlap_m = 0;

  overlap_max = 35;

  gap_pad = "nnnnnnnnnnnnnnn";

  if (process.argv.length < 3) {
    console.error("No inputs provided, use --help for assistance.");
    process.exit(1);
  }

  process.argv.shift();

  process.argv.shift();

  while (process.argv[0].slice(0, 2) === '--' || process.argv[0] === '-h') {
    p = process.argv.shift();
    parm = p.split('=');
    if (!((p[1] != null) || p === '-h' || p === '--help')) {
      console.error("Invalid parameter: " + p + ".  No integer value included.");
      process.exit(1);
    }
    switch (parm[0]) {
      case '--help':
      case '-h':
        console.warn("\nUsage: seq_scaffold [options] input.fna");
        console.warn('[options] : [-h|--help] [--overlap=<n>] [--max=<n>] [--trim=<n>] [--heal=<heafile.fna>] [--heal_overlap=<n>] [--heal_max=<n>] [--heal_trim=<n>] [--verbose]\n');
        console.warn("-h | --help  : Print this help text.");
        console.warn("--overlap=<n> : Minimum number of bases of overlap required to join contigs. Default: " + overlap_n);
        console.warn("--max=<n> : Maximum number of bases of overlap to look for. Default: " + overlap_max);
        console.warn("--trim=<n> : Maximum number of non-ambiguous bases to try trimming from contig ends when looking for overlap. Default: " + overlap_m);
        console.warn("--heal=<healfile.fna> : Use alternatively assembled contigs in the references FASTA file to try to \"heal\" gaps. Default: No Healing");
        console.warn("--heal_overlap=<n> : Minimum number of bases of overlap required to join contigs. Default: " + heal_n);
        console.warn("--heal_max=<n> : Maximum number of bases of gap to try to heal. Default: " + heal_max);
        console.warn("--heal_trim=<n> : Maximum number of non-ambiguous bases to try trimming from contig ends during healing. Default: " + heal_m);
        console.warn("--gap=<n> : Base number of 'n's (ambiguous bases) to insert in remaining gaps. Default: " + gap_pad.length);
        console.warn("--verbose : Output diagnostic messages to stderr. Default: " + verbose + "\n");
        console.warn("SEASTAR Version: " + ss_version + "\n");
        process.exit(1);
        break;
      case '--heal':
        heal_fn = parm[1];
        break;
      case '--heal_overlap':
        heal_n = Number(parm[1]);
        break;
      case '--heal_trim':
        heal_m = Number(parm[1]);
        break;
      case '--heal_max':
        heal_max = Number(parm[1]);
        break;
      case '--overlap':
        overlap_n = Number(parm[1]);
        break;
      case '--trim':
        overlap_m = Number(parm[1]);
        break;
      case '--max':
        overlap_max = Number(parm[1]);
        break;
      case '--gap':
        gap_pad = Array(Number(parm[1]) + 1).join("n");
        break;
      case '--verbose':
        verbose = true;
        break;
      default:
        console.error("Unknown parameter: " + p);
        process.exit(1);
    }
  }

  inputfn = process.argv[0];

  if (inputfn === '-') {
    input = process.stdin;
    input.resume();
  } else if (inputfn.slice(-3) === '.gz') {
    input = fs.createReadStream(inputfn).pipe(zlib.createGunzip());
  } else {
    input = fs.createReadStream(inputfn);
  }

  input.on('data', function(data) {
    return scaff_string = scaff_string.concat(data);
  }).on('end', function() {
    if (heal_fn) {
      if (heal_fn === '-') {
        input = process.stdin;
        input.resume();
      } else if (heal_fn.slice(-3) === '.gz') {
        input = fs.createReadStream(heal_fn).pipe(zlib.createGunzip());
      } else {
        input = fs.createReadStream(heal_fn);
      }
      return input.on('data', function(data) {
        return heal_string = heal_string.concat(data);
      }).on('end', function() {
        process_heal_fasta(heal_string);
        return process_scaffs(scaff_string);
      });
    } else {
      return process_scaffs(scaff_string);
    }
  });

}).call(this);
